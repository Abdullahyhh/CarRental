import * as i0 from '@angular/core';
import { ViewEncapsulation, ChangeDetectionStrategy, Component, NgModule, Inject, Injectable, provideAppInitializer, inject } from '@angular/core';
import { LpxModule } from '@volo/ngx-lepton-x.lite';
import { ValidationErrorComponent as ValidationErrorComponent$1, VALIDATION_ERROR_TEMPLATE, VALIDATION_TARGET_SELECTOR, VALIDATION_INVALID_CLASSES, NgxValidateCoreModule } from '@ngx-validate/core';
import * as i1 from '@abp/ng.core';
import { CoreModule, NAVIGATE_TO_MANAGE_PROFILE, getLocaleDirection, AuthService } from '@abp/ng.core';
import { CommonModule } from '@angular/common';
import { combineLatest, of } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as i3 from '@abp/ng.theme.shared';
import { UserMenuService } from '@abp/ng.theme.shared';
import * as i2 from '@volo/ngx-lepton-x.core';
import { LPX_TRANSLATE_SERVICE_TOKEN } from '@volo/ngx-lepton-x.core';
import { AbpToolbarService, AbpNavbarService, LeptonXAbpCoreModule } from '@volo/abp.ng.lepton-x.core';

class ValidationErrorComponent extends ValidationErrorComponent$1 {
    get abpErrors() {
        if (!this.errors || !this.errors.length)
            return [];
        return this.errors.map((error) => {
            if (!error.message)
                return { ...error, interpoliteParams: [] };
            const index = error.message.indexOf('[');
            if (index > -1) {
                return {
                    ...error,
                    message: error.message.slice(0, index),
                    interpoliteParams: error.message
                        .slice(index + 1, error.message.length - 1)
                        .split(','),
                };
            }
            return { ...error, interpoliteParams: [] };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ValidationErrorComponent, isStandalone: false, selector: "abp-validation-error", usesInheritance: true, ngImport: i0, template: `
    @for (error of abpErrors; track $index) {
      <div class="invalid-feedback">
        {{ error.message | abpLocalization: error.interpoliteParams }}
      </div>
    }
  `, isInline: true, dependencies: [{ kind: "pipe", type: i1.LocalizationPipe, name: "abpLocalization" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-validation-error',
                    template: `
    @for (error of abpErrors; track $index) {
      <div class="invalid-feedback">
        {{ error.message | abpLocalization: error.interpoliteParams }}
      </div>
    }
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }] });

class ValidationErrorModule {
    static forRoot() {
        return {
            ngModule: ValidationErrorModule,
            providers: [
                {
                    provide: VALIDATION_ERROR_TEMPLATE,
                    useValue: ValidationErrorComponent,
                },
                {
                    provide: VALIDATION_TARGET_SELECTOR,
                    useValue: '.form-group',
                },
                {
                    provide: VALIDATION_INVALID_CLASSES,
                    useValue: 'is-invalid',
                },
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorModule, declarations: [ValidationErrorComponent], imports: [CommonModule, CoreModule, NgxValidateCoreModule], exports: [ValidationErrorComponent, NgxValidateCoreModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorModule, imports: [CommonModule, CoreModule, NgxValidateCoreModule, NgxValidateCoreModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ValidationErrorModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ValidationErrorComponent],
                    imports: [CommonModule, CoreModule, NgxValidateCoreModule],
                    exports: [ValidationErrorComponent, NgxValidateCoreModule],
                }]
        }] });

class AbpUserProfileService {
    constructor(configState, userProfileService, navigateToManageProfile, userMenuService) {
        this.configState = configState;
        this.userProfileService = userProfileService;
        this.navigateToManageProfile = navigateToManageProfile;
        this.userMenuService = userMenuService;
        this.currentUser$ = this.configState.getOne$('currentUser');
    }
    subscribeUser() {
        combineLatest([
            this.currentUser$.pipe(filter(Boolean)),
            this.userMenuService.items$,
        ]).subscribe(([user, userMenuItems]) => {
            const userActionGroups = userMenuItems.reduce((acc, curr) => {
                const menuItem = {
                    icon: curr.textTemplate?.icon,
                    text: curr.textTemplate?.text,
                    component: curr?.component,
                    action: () => {
                        curr.action();
                        return of(true);
                    },
                };
                acc[0].push(menuItem);
                return acc;
            }, [[]]);
            this.userProfileService.setUser({
                id: user.id,
                isAuthenticated: user.isAuthenticated,
                fullName: user.name || user.userName || '',
                email: user.email || '',
                userName: user.userName || '',
                avatar: {
                    type: 'icon',
                    source: 'bi bi-person-circle',
                },
                userActionGroups,
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpUserProfileService, deps: [{ token: i1.ConfigStateService }, { token: i2.UserProfileService }, { token: NAVIGATE_TO_MANAGE_PROFILE }, { token: i3.UserMenuService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpUserProfileService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpUserProfileService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i1.ConfigStateService }, { type: i2.UserProfileService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NAVIGATE_TO_MANAGE_PROFILE]
                }] }, { type: i3.UserMenuService }] });

const LPX_USER_PROVIDER = provideAppInitializer(() => {
    const userProfile = inject(AbpUserProfileService);
    userProfile.subscribeUser();
});

class AbpLanguageService {
    constructor(configState, languageService, sessionState) {
        this.configState = configState;
        this.languageService = languageService;
        this.sessionState = sessionState;
        this.languages$ = this.configState.getDeep$('localization.languages');
        this.mapLang = (lang) => {
            return {
                cultureName: lang.cultureName,
                displayName: lang.displayName || '',
                selected: this.sessionState.getLanguage() === lang.cultureName,
                twoLetterISOLanguageName: lang.twoLetterISOLanguageName || '', //any is a workaround for the missing property in the LanguageInfo interface, if abp was updated to 7.0.2 or greater, this should be removed
                isRTL: getLocaleDirection(lang.cultureName) === 'rtl',
            };
        };
    }
    subscribeLanguage() {
        this.languages$.pipe(filter(Boolean)).subscribe(langs => {
            this.languageService.init(langs.map(this.mapLang));
        });
        this.languageService.selectedLanguage$
            .pipe(filter(Boolean))
            .subscribe(lang => {
            this.sessionState.setLanguage(lang?.cultureName || '');
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpLanguageService, deps: [{ token: i1.ConfigStateService }, { token: i2.LanguageService }, { token: i1.SessionStateService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpLanguageService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpLanguageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i1.ConfigStateService }, { type: i2.LanguageService }, { type: i1.SessionStateService }] });

const LPX_LANGUAGE_PROVIDER = provideAppInitializer(() => {
    const languageService = inject(AbpLanguageService);
    languageService.subscribeLanguage();
});

class AbpTranslateService {
    constructor(localization) {
        this.localization = localization;
    }
    get(key, defaultValue) {
        const keyToTranslate = this.getKey(key);
        if (keyToTranslate) {
            return this.localization.instant({
                key: keyToTranslate,
                defaultValue,
            });
        }
        return defaultValue || key;
    }
    get$(key, defaultValue) {
        const keyToTranslate = this.getKey(key);
        if (keyToTranslate) {
            return this.localization.get({
                key: keyToTranslate,
                defaultValue,
            });
        }
        return of(defaultValue || key);
    }
    getKey(key) {
        return key.includes('::') ? key : undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpTranslateService, deps: [{ token: i1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpTranslateService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpTranslateService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.LocalizationService }] });

const LPX_TRANSLATE_PROVIDER = {
    provide: LPX_TRANSLATE_SERVICE_TOKEN,
    useClass: AbpTranslateService,
};

var eUserMenuItems;
(function (eUserMenuItems) {
    eUserMenuItems["MyAccount"] = "MyAccount";
    eUserMenuItems["Logout"] = "Logout";
})(eUserMenuItems || (eUserMenuItems = {}));

const LEPTON_X_USER_MENU_PROVIDERS = [
    provideAppInitializer(() => {
        configureUserMenu();
    }),
];
function configureUserMenu() {
    const userMenu = inject(UserMenuService);
    const authService = inject(AuthService);
    const navigateToManageProfile = inject(NAVIGATE_TO_MANAGE_PROFILE);
    userMenu.addItems([
        {
            id: eUserMenuItems.MyAccount,
            order: 100,
            textTemplate: {
                text: 'AbpAccount::MyAccount',
            },
            action: () => navigateToManageProfile(),
        },
        {
            id: eUserMenuItems.Logout,
            order: 101,
            textTemplate: {
                text: 'AbpUi::Logout',
            },
            action: () => authService.logout().subscribe(),
        },
    ]);
}

const INIT_SERVICE_PROVIDER = provideAppInitializer(() => {
    const abpToolbarService = inject(AbpToolbarService);
    const abpNavbarService = inject(AbpNavbarService);
    abpToolbarService.listenNavItems();
    abpNavbarService.initRoutes();
});

class ThemeLeptonXModule {
    static forRoot(options) {
        return {
            ngModule: ThemeLeptonXModule,
            providers: [
                LpxModule.forRoot(createLpxModuleOptions(options))
                    .providers,
                ValidationErrorModule.forRoot().providers,
                LPX_USER_PROVIDER,
                LPX_LANGUAGE_PROVIDER,
                LPX_TRANSLATE_PROVIDER,
                LEPTON_X_USER_MENU_PROVIDERS,
                INIT_SERVICE_PROVIDER,
                LeptonXAbpCoreModule.forRoot().providers,
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeLeptonXModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: ThemeLeptonXModule, imports: [LpxModule, ValidationErrorModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeLeptonXModule, imports: [LpxModule, ValidationErrorModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeLeptonXModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [LpxModule, ValidationErrorModule],
                    exports: [],
                }]
        }] });
function createLpxModuleOptions(options) {
    return {
        ...options,
        styleFactory: (styles) => {
            styles.push({
                bundleName: 'abp-bundle',
            });
            if (options?.styleFactory) {
                return options.styleFactory(styles);
            }
            return styles;
        },
    };
}

/*
 * Public API Surface of theme-lepton-x
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbpLanguageService, AbpTranslateService, AbpUserProfileService, INIT_SERVICE_PROVIDER, LEPTON_X_USER_MENU_PROVIDERS, LPX_LANGUAGE_PROVIDER, LPX_TRANSLATE_PROVIDER, LPX_USER_PROVIDER, ThemeLeptonXModule, ValidationErrorComponent, ValidationErrorModule, configureUserMenu, eUserMenuItems };
//# sourceMappingURL=abp-ng.theme.lepton-x.mjs.map
