import * as i0 from '@angular/core';
import { Injectable, Input, Component, ChangeDetectionStrategy, EventEmitter, ViewChild, Output, InjectionToken, Inject, inject, DestroyRef, createComponent, ViewEncapsulation, model, input, viewChild, contentChild, output, effect, HostListener, Optional, Directive, forwardRef, HostBinding, NgModule, ChangeDetectorRef, ViewContainerRef, Renderer2, Host, RendererFactory2, Injector, EnvironmentInjector, ApplicationRef, provideAppInitializer, LOCALE_ID, makeEnvironmentProviders } from '@angular/core';
import * as i1 from '@angular/common';
import { formatDate, DOCUMENT, CommonModule, DatePipe } from '@angular/common';
import { NgbDateAdapter, NgbTimeAdapter, NgbModal, NgbTooltip, NgbInputDatepickerConfig, NgbTypeaheadConfig, NgbDateParserFormatter, NgbPaginationModule } from '@ng-bootstrap/ng-bootstrap';
import { animation, style, animate, keyframes, trigger, state, transition, useAnimation, query } from '@angular/animations';
import * as i1$1 from '@angular/router';
import { Router, ResolveEnd } from '@angular/router';
import * as i2 from '@abp/ng.core';
import { getRoutePath, SubscriptionService, PROJECTION_STRATEGY, uuid, AbstractNgModelComponent, InternetConnectionService, LocalizationModule, LocalizationService, getLocaleDirection, DomInsertionService, CONTENT_STRATEGY, SORT_COMPARE_FUNC, InternalStore, ContentProjectionService, RouterEvents, AuthService, SessionStateService, ConfigStateService, HttpErrorReporterService, RoutesService, TENANT_NOT_FOUND_BY_NAME, CoreModule } from '@abp/ng.core';
import { startWith, map, debounceTime, filter, takeUntil, take, switchMap } from 'rxjs/operators';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent, Subscription, combineLatest, timer, ReplaySubject, Subject, distinctUntilChanged, of, from, Observable, EMPTY, BehaviorSubject } from 'rxjs';
import * as i2$1 from '@angular/forms';
import { FormsModule, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import * as i1$2 from '@swimlane/ngx-datatable';
import { ColumnMode, DatatableComponent, NgxDatatableModule } from '@swimlane/ngx-datatable';
import { HttpErrorResponse } from '@angular/common/http';
import { normalizeDiacritics, VALIDATION_BLUEPRINTS, defaultMapErrorsFn, VALIDATION_MAP_ERRORS_FN, VALIDATION_VALIDATE_ON_SUBMIT, NgxValidateCoreModule } from '@ngx-validate/core';

class DateTimeAdapter {
    fromModel(value) {
        if (!value) {
            return null;
        }
        const date = new Date(value);
        if (isNaN(date)) {
            return null;
        }
        this.value = {
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
        return this.value;
    }
    toModel(value) {
        if (!value) {
            return '';
        }
        const now = new Date();
        const newValue = {
            year: now.getUTCFullYear(),
            month: now.getMonth() + 1,
            day: now.getDate(),
            hour: 0,
            minute: 0,
            second: 0,
            ...this.value,
            ...value,
        };
        const date = new Date(Date.UTC(newValue.year, newValue.month - 1, newValue.day, newValue.hour, newValue.minute, newValue.second));
        return date.toISOString().replace('Z', '');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateTimeAdapter, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateTimeAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateTimeAdapter, decorators: [{
            type: Injectable
        }] });

class DateAdapter extends NgbDateAdapter {
    fromModel(value) {
        if (!value)
            return null;
        let date;
        if (typeof value === 'string') {
            date = this.dateOf(value);
        }
        else {
            date = new Date(value);
        }
        if (isNaN(date))
            return null;
        return {
            day: date.getDate(),
            month: date.getMonth() + 1,
            year: date.getFullYear(),
        };
    }
    toModel(value) {
        if (!value)
            return '';
        const date = new Date(value.year, value.month - 1, value.day);
        const formattedDate = formatDate(date, 'yyyy-MM-dd', 'en');
        return formattedDate;
    }
    dateOf(value) {
        const dateUtc = new Date(Date.parse(value));
        return new Date(dateUtc.getTime() + Math.abs(dateUtc.getTimezoneOffset() * 60000));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateAdapter, decorators: [{
            type: Injectable
        }] });

class TimeAdapter extends NgbTimeAdapter {
    fromModel(value) {
        if (!value)
            return null;
        const date = isTimeStr(value)
            ? new Date(0, 0, 1, ...value.split(':').map(Number))
            : new Date(value);
        if (isNaN(date))
            return null;
        return {
            hour: date.getHours(),
            minute: date.getMinutes(),
            second: date.getSeconds(),
        };
    }
    toModel(value) {
        if (!value) {
            return null;
        }
        const date = new Date(0, 0, 1, value.hour, value.minute, value.second);
        const formattedDate = formatDate(date, 'HH:mm:ss', 'en');
        return formattedDate;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TimeAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TimeAdapter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TimeAdapter, decorators: [{
            type: Injectable
        }] });
function isTimeStr(value) {
    return /^((2[123])|[01][0-9])(:[0-5][0-9]){1,2}$/.test(String(value));
}

const bounceIn = animation([
    style({ opacity: '0', display: '{{ display }}' }),
    animate('{{ time}} {{ easing }}', keyframes([
        style({ opacity: '0', transform: '{{ transform }} scale(0.0)', offset: 0 }),
        style({ opacity: '0', transform: '{{ transform }} scale(0.8)', offset: 0.5 }),
        style({ opacity: '1', transform: '{{ transform }} scale(1.0)', offset: 1 }),
    ])),
], {
    params: {
        time: '350ms',
        easing: 'cubic-bezier(.7,.31,.72,1.47)',
        display: 'block',
        transform: 'translate(-50%, -50%)',
    },
});

const collapseY = animation([
    style({ height: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapseYWithMargin = animation([
    style({ 'margin-top': '0' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-left': '-100%' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const collapseX = animation([
    style({ width: '*', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '0', padding: '0px' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandY = animation([
    style({ height: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ height: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const expandYWithMargin = animation([
    style({ 'margin-top': '-100%' }),
    animate('{{ time }} {{ easing }}', style({ 'margin-top': '0' })),
], {
    params: { time: '500ms', easing: 'ease' },
});
const expandX = animation([
    style({ width: '0', overflow: 'hidden', 'box-sizing': 'border-box' }),
    animate('{{ time }} {{ easing }}', style({ width: '*', padding: '*' })),
], { params: { time: '350ms', easing: 'ease' } });
const collapse = trigger('collapse', [
    state('collapsed', style({ height: '0', overflow: 'hidden' })),
    state('expanded', style({ height: '*', overflow: 'hidden' })),
    transition('expanded => collapsed', useAnimation(collapseY)),
    transition('collapsed => expanded', useAnimation(expandY)),
]);
const collapseWithMargin = trigger('collapseWithMargin', [
    state('collapsed', style({ 'margin-top': '-100%' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin), {
        params: { time: '400ms', easing: 'linear' },
    }),
    transition('collapsed => expanded', useAnimation(expandYWithMargin)),
]);
const collapseLinearWithMargin = trigger('collapseLinearWithMargin', [
    state('collapsed', style({ 'margin-top': '-100vh' })),
    state('expanded', style({ 'margin-top': '0' })),
    transition('expanded => collapsed', useAnimation(collapseYWithMargin, { params: { time: '200ms', easing: 'linear' } })),
    transition('collapsed => expanded', useAnimation(expandYWithMargin, { params: { time: '250ms', easing: 'linear' } })),
]);

const fadeIn = animation([style({ opacity: '0' }), animate('{{ time}} {{ easing }}', style({ opacity: '1' }))], {
    params: { time: '350ms', easing: 'ease' },
});
const fadeOut = animation([style({ opacity: '1' }), animate('{{ time}} {{ easing }}', style({ opacity: '0' }))], { params: { time: '350ms', easing: 'ease' } });
const fadeInDown = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInUp = animation([
    style({ opacity: '0', transform: '{{ transform }} translateY(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateY(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInLeft = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeInRight = animation([
    style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '1', transform: '{{ transform }} translateX(0)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutDown = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutUp = animation([
    style({ opacity: '1', transform: '{{ transform }} translateY(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateY(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutLeft = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });
const fadeOutRight = animation([
    style({ opacity: '1', transform: '{{ transform }} translateX(0)' }),
    animate('{{ time }} {{ easing }}', style({ opacity: '0', transform: '{{ transform }} translateX(-20px)' })),
], { params: { time: '350ms', easing: 'ease', transform: '' } });

const fadeAnimation = trigger('fade', [
    transition(':enter', useAnimation(fadeIn)),
    transition(':leave', useAnimation(fadeOut)),
]);
const dialogAnimation = trigger('dialog', [
    transition(':enter', useAnimation(fadeInDown)),
    transition(':leave', useAnimation(fadeOut)),
]);

const slideFromBottom = trigger('slideFromBottom', [
    transition('* <=> *', [
        style({ 'margin-top': '20px', opacity: '0' }),
        animate('0.2s ease-out', style({ opacity: '1', 'margin-top': '0px' })),
    ]),
]);

const toastInOut = trigger('toastInOut', [
    transition('* <=> *', [
        query(':enter', [
            style({ opacity: 0, transform: 'translateY(20px)' }),
            animate('350ms ease', style({ opacity: 1, transform: 'translateY(0)' })),
        ], { optional: true }),
        query(':leave', animate('450ms ease', style({ opacity: 0 })), {
            optional: true,
        }),
    ]),
]);

class BreadcrumbItemsComponent {
    constructor() {
        this.items = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BreadcrumbItemsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: BreadcrumbItemsComponent, isStandalone: false, selector: "abp-breadcrumb-items", inputs: { items: "items" }, ngImport: i0, template: "@if (items.length) {\r\n  <ol class=\"breadcrumb\">\r\n    <li class=\"breadcrumb-item\">\r\n      <a routerLink=\"/\"><i class=\"fa fa-home\" aria-hidden=\"true\"></i> </a>\r\n    </li>\r\n    @for (item of items; track $index; let last = $last) {\r\n      <li class=\"breadcrumb-item\" [class.active]=\"last\" aria-current=\"page\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"item.path ? linkTemplate : textTemplate; context: { $implicit: item }\"\r\n        ></ng-container>\r\n      </li>\r\n    }\r\n  </ol>\r\n}\r\n\r\n<ng-template #linkTemplate let-item>\r\n  <a [routerLink]=\"item.path\"> {{ item.name | abpLocalization }}</a>\r\n</ng-template>\r\n\r\n<ng-template #textTemplate let-item>\r\n  {{ item.name | abpLocalization }}\r\n</ng-template>\r\n", dependencies: [{ kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1$1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BreadcrumbItemsComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-breadcrumb-items', template: "@if (items.length) {\r\n  <ol class=\"breadcrumb\">\r\n    <li class=\"breadcrumb-item\">\r\n      <a routerLink=\"/\"><i class=\"fa fa-home\" aria-hidden=\"true\"></i> </a>\r\n    </li>\r\n    @for (item of items; track $index; let last = $last) {\r\n      <li class=\"breadcrumb-item\" [class.active]=\"last\" aria-current=\"page\">\r\n        <ng-container\r\n          *ngTemplateOutlet=\"item.path ? linkTemplate : textTemplate; context: { $implicit: item }\"\r\n        ></ng-container>\r\n      </li>\r\n    }\r\n  </ol>\r\n}\r\n\r\n<ng-template #linkTemplate let-item>\r\n  <a [routerLink]=\"item.path\"> {{ item.name | abpLocalization }}</a>\r\n</ng-template>\r\n\r\n<ng-template #textTemplate let-item>\r\n  {{ item.name | abpLocalization }}\r\n</ng-template>\r\n" }]
        }], propDecorators: { items: [{
                type: Input
            }] } });

class BreadcrumbComponent {
    constructor(cdRef, router, routes, subscription, routerEvents) {
        this.cdRef = cdRef;
        this.router = router;
        this.routes = routes;
        this.subscription = subscription;
        this.routerEvents = routerEvents;
        this.segments = [];
    }
    ngOnInit() {
        this.subscription.addOne(this.routerEvents.getNavigationEvents('End').pipe(startWith(null), map(() => this.routes.search({ path: getRoutePath(this.router) }))), route => {
            this.segments = [];
            if (route) {
                let node = { parent: route };
                while (node.parent) {
                    node = node.parent;
                    const { parent, children, isLeaf, path, ...segment } = node;
                    if (!isAdministration(segment))
                        this.segments.unshift(segment);
                }
                this.cdRef.detectChanges();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BreadcrumbComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1$1.Router }, { token: i2.RoutesService }, { token: i2.SubscriptionService }, { token: i2.RouterEvents }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: BreadcrumbComponent, isStandalone: false, selector: "abp-breadcrumb", providers: [SubscriptionService], ngImport: i0, template: "<abp-breadcrumb-items [items]=\"segments\"></abp-breadcrumb-items>\r\n", dependencies: [{ kind: "component", type: BreadcrumbItemsComponent, selector: "abp-breadcrumb-items", inputs: ["items"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-breadcrumb', changeDetection: ChangeDetectionStrategy.OnPush, providers: [SubscriptionService], template: "<abp-breadcrumb-items [items]=\"segments\"></abp-breadcrumb-items>\r\n" }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i1$1.Router }, { type: i2.RoutesService }, { type: i2.SubscriptionService }, { type: i2.RouterEvents }] });
function isAdministration(route) {
    return route.name === "AbpUiNavigation::Menu:Administration" /* eThemeSharedRouteNames.Administration */;
}

class ButtonComponent {
    get icon() {
        return `${this.loading ? 'fa fa-spinner fa-spin' : this.iconClass || 'd-none'}`;
    }
    constructor(renderer) {
        this.renderer = renderer;
        this.buttonId = '';
        this.buttonClass = 'btn btn-primary';
        this.buttonType = 'button';
        this.formName = undefined;
        this.loading = false;
        this.disabled = false;
        this.click = new EventEmitter();
        this.focus = new EventEmitter();
        this.blur = new EventEmitter();
        this.abpClick = new EventEmitter();
        this.abpFocus = new EventEmitter();
        this.abpBlur = new EventEmitter();
    }
    ngOnInit() {
        if (this.attributes) {
            Object.keys(this.attributes).forEach(key => {
                if (this.attributes?.[key]) {
                    this.renderer.setAttribute(this.buttonRef.nativeElement, key, this.attributes[key]);
                }
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ButtonComponent, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: ButtonComponent, isStandalone: false, selector: "abp-button", inputs: { buttonId: "buttonId", buttonClass: "buttonClass", buttonType: "buttonType", formName: "formName", iconClass: "iconClass", loading: "loading", disabled: "disabled", attributes: "attributes" }, outputs: { click: "click", focus: "focus", blur: "blur", abpClick: "abpClick", abpFocus: "abpFocus", abpBlur: "abpBlur" }, viewQueries: [{ propertyName: "buttonRef", first: true, predicate: ["button"], descendants: true, static: true }], ngImport: i0, template: `
    <button
      #button
      [id]="buttonId"
      [attr.type]="buttonType"
      [attr.form]="formName"
      [ngClass]="buttonClass"
      [disabled]="loading || disabled"
      (click.stop)="click.next($event); abpClick.next($event)"
      (focus)="focus.next($event); abpFocus.next($event)"
      (blur)="blur.next($event); abpBlur.next($event)"
    >
      <i [ngClass]="icon" class="me-1" aria-hidden="true"></i><ng-content></ng-content>
    </button>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.StopPropagationDirective, selector: "[click.stop]", outputs: ["click.stop"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ButtonComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-button',
                    template: `
    <button
      #button
      [id]="buttonId"
      [attr.type]="buttonType"
      [attr.form]="formName"
      [ngClass]="buttonClass"
      [disabled]="loading || disabled"
      (click.stop)="click.next($event); abpClick.next($event)"
      (focus)="focus.next($event); abpFocus.next($event)"
      (blur)="blur.next($event); abpBlur.next($event)"
    >
      <i [ngClass]="icon" class="me-1" aria-hidden="true"></i><ng-content></ng-content>
    </button>
  `,
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }], propDecorators: { buttonId: [{
                type: Input
            }], buttonClass: [{
                type: Input
            }], buttonType: [{
                type: Input
            }], formName: [{
                type: Input
            }], iconClass: [{
                type: Input
            }], loading: [{
                type: Input
            }], disabled: [{
                type: Input
            }], attributes: [{
                type: Input
            }], click: [{
                type: Output
            }], focus: [{
                type: Output
            }], blur: [{
                type: Output
            }], abpClick: [{
                type: Output
            }], abpFocus: [{
                type: Output
            }], abpBlur: [{
                type: Output
            }], buttonRef: [{
                type: ViewChild,
                args: ['button', { static: true }]
            }] } });

var Confirmation;
(function (Confirmation) {
    let Status;
    (function (Status) {
        Status["confirm"] = "confirm";
        Status["reject"] = "reject";
        Status["dismiss"] = "dismiss";
    })(Status = Confirmation.Status || (Confirmation.Status = {}));
})(Confirmation || (Confirmation = {}));

const CONFIRMATION_ICONS = new InjectionToken('CONFIRMATION_ICONS');
const DEFAULT_CONFIRMATION_ICONS = {
    info: 'fa fa-info-circle',
    success: 'fa fa-check-circle',
    warning: 'fa fa-exclamation-triangle',
    error: 'fa fa-times-circle',
    default: 'fa fa-question-circle',
    neutral: '',
};

class ConfirmationComponent {
    constructor(icons) {
        this.icons = icons;
        this.confirm = Confirmation.Status.confirm;
        this.reject = Confirmation.Status.reject;
        this.dismiss = Confirmation.Status.dismiss;
    }
    close(status) {
        this.clear(status);
    }
    getIconClass({ severity, options }) {
        if (options && options.icon) {
            return options.icon;
        }
        if (!this.icons) {
            return '';
        }
        if (severity) {
            return this.icons[severity];
        }
        return this.icons.default;
    }
    isCustomIconExists({ options }) {
        return !!(options && (options.iconTemplate || options.icon));
    }
    isIconTemplateExits({ options }) {
        return !!(options && options.iconTemplate);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ConfirmationComponent, deps: [{ token: CONFIRMATION_ICONS }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ConfirmationComponent, isStandalone: false, selector: "abp-confirmation", ngImport: i0, template: "@if (confirmation$ | async; as data) {\r\n  <div class=\"confirmation\">\r\n    <div\r\n      class=\"confirmation-backdrop\"\r\n      (click)=\"data.options?.dismissible ? close(dismiss) : null\"\r\n    ></div>\r\n    <div class=\"confirmation-dialog\">\r\n      @if (data.severity || isCustomIconExists(data)) {\r\n        <div class=\"icon-container\" [ngClass]=\"data.severity\">\r\n          @if (isIconTemplateExits(data)) {\r\n            <div [outerHTML]=\"data.options.iconTemplate\"></div>\r\n          } @else {\r\n            <i class=\"icon\" [ngClass]=\"getIconClass(data)\"></i>\r\n          }\r\n        </div>\r\n      }\r\n      <div class=\"content\">\r\n        @if (data.title) {\r\n          <h1\r\n            class=\"title\"\r\n            [innerHTML]=\"data.title | abpLocalization: data.options?.titleLocalizationParams\"\r\n          ></h1>\r\n        }\r\n        @if (data.message) {\r\n          <p\r\n            class=\"message\"\r\n            [innerHTML]=\"data.message | abpLocalization: data.options?.messageLocalizationParams\"\r\n          ></p>\r\n        }\r\n      </div>\r\n      <div class=\"footer\">\r\n        @if (!data?.options?.hideCancelBtn) {\r\n          <button\r\n            id=\"cancel\"\r\n            class=\"btn btn-outline-primary me-2\"\r\n            [innerHTML]=\"data.options?.cancelText || 'AbpUi::Cancel' | abpLocalization\"\r\n            (click)=\"close(reject)\"\r\n          ></button>\r\n        }\r\n        @if (!data?.options?.hideYesBtn) {\r\n          <button\r\n            id=\"confirm\"\r\n            class=\"btn btn-primary\"\r\n            [innerHTML]=\"data.options?.yesText || 'AbpUi::Yes' | abpLocalization\"\r\n            (click)=\"close(confirm)\"\r\n          ></button>\r\n        }\r\n      </div>\r\n    </div>\r\n  </div>\r\n}\r\n", styles: [".confirmation{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1060}.confirmation .confirmation-backdrop{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1061!important}.confirmation .confirmation-dialog{display:flex;flex-direction:column;margin:20px auto;padding:0;width:450px;min-height:300px;z-index:1062!important}@media screen and (max-width: 500px){.confirmation .confirmation-dialog{width:90vw}}.confirmation .confirmation-dialog .icon-container{display:flex;align-items:center;justify-content:center;padding:40px 20px 10px}.confirmation .confirmation-dialog .icon-container .icon{width:100px;height:100px;stroke-width:1;font-size:80px;text-align:center}.confirmation .confirmation-dialog .content{flex-grow:1;display:block}.confirmation .confirmation-dialog .content .title{display:block;margin:0;padding:0;font-size:27px;font-weight:600;text-align:center}.confirmation .confirmation-dialog .content .message{display:block;padding:8px 20px 20px;font-size:16px;font-weight:400;text-align:center;margin-bottom:0}.confirmation .confirmation-dialog .footer{display:flex;align-items:center;justify-content:flex-end;padding:20px;width:100%}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ConfirmationComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-confirmation', template: "@if (confirmation$ | async; as data) {\r\n  <div class=\"confirmation\">\r\n    <div\r\n      class=\"confirmation-backdrop\"\r\n      (click)=\"data.options?.dismissible ? close(dismiss) : null\"\r\n    ></div>\r\n    <div class=\"confirmation-dialog\">\r\n      @if (data.severity || isCustomIconExists(data)) {\r\n        <div class=\"icon-container\" [ngClass]=\"data.severity\">\r\n          @if (isIconTemplateExits(data)) {\r\n            <div [outerHTML]=\"data.options.iconTemplate\"></div>\r\n          } @else {\r\n            <i class=\"icon\" [ngClass]=\"getIconClass(data)\"></i>\r\n          }\r\n        </div>\r\n      }\r\n      <div class=\"content\">\r\n        @if (data.title) {\r\n          <h1\r\n            class=\"title\"\r\n            [innerHTML]=\"data.title | abpLocalization: data.options?.titleLocalizationParams\"\r\n          ></h1>\r\n        }\r\n        @if (data.message) {\r\n          <p\r\n            class=\"message\"\r\n            [innerHTML]=\"data.message | abpLocalization: data.options?.messageLocalizationParams\"\r\n          ></p>\r\n        }\r\n      </div>\r\n      <div class=\"footer\">\r\n        @if (!data?.options?.hideCancelBtn) {\r\n          <button\r\n            id=\"cancel\"\r\n            class=\"btn btn-outline-primary me-2\"\r\n            [innerHTML]=\"data.options?.cancelText || 'AbpUi::Cancel' | abpLocalization\"\r\n            (click)=\"close(reject)\"\r\n          ></button>\r\n        }\r\n        @if (!data?.options?.hideYesBtn) {\r\n          <button\r\n            id=\"confirm\"\r\n            class=\"btn btn-primary\"\r\n            [innerHTML]=\"data.options?.yesText || 'AbpUi::Yes' | abpLocalization\"\r\n            (click)=\"close(confirm)\"\r\n          ></button>\r\n        }\r\n      </div>\r\n    </div>\r\n  </div>\r\n}\r\n", styles: [".confirmation{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:1060}.confirmation .confirmation-backdrop{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1061!important}.confirmation .confirmation-dialog{display:flex;flex-direction:column;margin:20px auto;padding:0;width:450px;min-height:300px;z-index:1062!important}@media screen and (max-width: 500px){.confirmation .confirmation-dialog{width:90vw}}.confirmation .confirmation-dialog .icon-container{display:flex;align-items:center;justify-content:center;padding:40px 20px 10px}.confirmation .confirmation-dialog .icon-container .icon{width:100px;height:100px;stroke-width:1;font-size:80px;text-align:center}.confirmation .confirmation-dialog .content{flex-grow:1;display:block}.confirmation .confirmation-dialog .content .title{display:block;margin:0;padding:0;font-size:27px;font-weight:600;text-align:center}.confirmation .confirmation-dialog .content .message{display:block;padding:8px 20px 20px;font-size:16px;font-weight:400;text-align:center;margin-bottom:0}.confirmation .confirmation-dialog .footer{display:flex;align-items:center;justify-content:flex-end;padding:20px;width:100%}\n"] }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [CONFIRMATION_ICONS]
                }] }] });

class HttpErrorWrapperComponent {
    constructor() {
        this.destroyRef = inject(DestroyRef);
        this.document = inject(DOCUMENT);
        this.window = this.document.defaultView;
        this.router = inject(Router);
        this.status = 0;
        this.title = 'Oops!';
        this.details = 'Sorry, an error has occured.';
        this.customComponent = undefined;
        this.hideCloseIcon = false;
        this.isHomeShow = true;
    }
    get statusText() {
        return this.status ? `[${this.status}]` : '';
    }
    ngOnInit() {
        const computedStyle = this.window.getComputedStyle(this.document.body);
        const backgroundColor = computedStyle?.getPropertyValue('background-color');
        this.backgroundColor = backgroundColor || '#fff';
    }
    ngAfterViewInit() {
        if (this.customComponent) {
            const customComponentRef = createComponent(this.customComponent, {
                environmentInjector: this.environmentInjector,
            });
            customComponentRef.instance.errorStatus = this.status;
            //In our custom "HttpErrorComponent", we have a "status" property.
            //We used to have "errorStatus", but it wasn't signal type. "status" variable is signal type.
            //I've checked because of backward compatibility. Developers might have their own custom HttpErrorComponent.
            //We need to deprecated and remove "errorStatus" in the future.
            if (customComponentRef.instance.status) {
                customComponentRef.instance.status.set(this.status);
            }
            customComponentRef.instance.destroy$ = this.destroy$;
            this.appRef.attachView(customComponentRef.hostView);
            if (this.containerRef) {
                this.containerRef.nativeElement.appendChild(customComponentRef.hostView.rootNodes[0]);
            }
            customComponentRef.changeDetectorRef.detectChanges();
        }
        fromEvent(this.document, 'keyup')
            .pipe(debounceTime(150), filter((key) => key && key.key === 'Escape'), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => this.destroy());
    }
    goHome() {
        this.router.navigateByUrl('/', { onSameUrlNavigation: 'reload' });
        this.destroy();
    }
    destroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    ngOnDestroy() {
        this.destroy();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: HttpErrorWrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: HttpErrorWrapperComponent, isStandalone: false, selector: "abp-http-error-wrapper", viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["container"], descendants: true }], ngImport: i0, template: "<div\r\n  #container\r\n  id=\"abp-http-error-container\"\r\n  class=\"error\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  @if (!hideCloseIcon) {\r\n    <button id=\"abp-close-button\" type=\"button\" class=\"btn-close me-2\" (click)=\"destroy()\"></button>\r\n  }\r\n\r\n  @if (!customComponent) {\r\n    <div class=\"row centered\">\r\n      <div class=\"col-md-12\">\r\n        <div class=\"error-template\">\r\n          <h1>{{ statusText }} {{ title | abpLocalization }}</h1>\r\n          <div class=\"error-details\">\r\n            {{ details | abpLocalization }}\r\n          </div>\r\n          <div class=\"error-actions\">\r\n            @if (isHomeShow) {\r\n              <a (click)=\"goHome()\" class=\"btn btn-primary btn-md mt-2\"\r\n                ><span class=\"glyphicon glyphicon-home\"></span>\r\n                {{ { key: '::Menu:Home', defaultValue: 'Home' } | abpLocalization }}\r\n              </a>\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  }\r\n</div>\r\n", styles: [".error{position:fixed;top:0;width:100vw;height:100vh;z-index:999999}.centered{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}\n"], dependencies: [{ kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: HttpErrorWrapperComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-http-error-wrapper', template: "<div\r\n  #container\r\n  id=\"abp-http-error-container\"\r\n  class=\"error\"\r\n  [style.backgroundColor]=\"backgroundColor\"\r\n>\r\n  @if (!hideCloseIcon) {\r\n    <button id=\"abp-close-button\" type=\"button\" class=\"btn-close me-2\" (click)=\"destroy()\"></button>\r\n  }\r\n\r\n  @if (!customComponent) {\r\n    <div class=\"row centered\">\r\n      <div class=\"col-md-12\">\r\n        <div class=\"error-template\">\r\n          <h1>{{ statusText }} {{ title | abpLocalization }}</h1>\r\n          <div class=\"error-details\">\r\n            {{ details | abpLocalization }}\r\n          </div>\r\n          <div class=\"error-actions\">\r\n            @if (isHomeShow) {\r\n              <a (click)=\"goHome()\" class=\"btn btn-primary btn-md mt-2\"\r\n                ><span class=\"glyphicon glyphicon-home\"></span>\r\n                {{ { key: '::Menu:Home', defaultValue: 'Home' } | abpLocalization }}\r\n              </a>\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  }\r\n</div>\r\n", styles: [".error{position:fixed;top:0;width:100vw;height:100vh;z-index:999999}.centered{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}\n"] }]
        }], propDecorators: { containerRef: [{
                type: ViewChild,
                args: ['container', { static: false }]
            }] } });

class LoaderBarComponent {
    set isLoading(value) {
        this._isLoading = value;
        this.cdRef.detectChanges();
    }
    get isLoading() {
        return this._isLoading;
    }
    get boxShadow() {
        return `0 0 10px rgba(${this.color}, 0.5)`;
    }
    constructor(router, cdRef, subscription, httpWaitService, routerWaitService) {
        this.router = router;
        this.cdRef = cdRef;
        this.subscription = subscription;
        this.httpWaitService = httpWaitService;
        this.routerWaitService = routerWaitService;
        this.containerClass = 'abp-loader-bar';
        this.color = '#77b6ff';
        this.progressLevel = 0;
        this.interval = new Subscription();
        this.timer = new Subscription();
        this.intervalPeriod = 350;
        this.stopDelay = 800;
        this.clearProgress = () => {
            this.progressLevel = 0;
            this.cdRef.detectChanges();
        };
        this.reportProgress = () => {
            if (this.progressLevel < 75) {
                this.progressLevel += 1 + Math.random() * 9;
            }
            else if (this.progressLevel < 90) {
                this.progressLevel += 0.4;
            }
            else if (this.progressLevel < 100) {
                this.progressLevel += 0.1;
            }
            else {
                this.interval.unsubscribe();
            }
            this.cdRef.detectChanges();
        };
    }
    ngOnInit() {
        this.subscribeLoading();
    }
    subscribeLoading() {
        this.subscription.addOne(combineLatest([this.httpWaitService.getLoading$(), this.routerWaitService.getLoading$()]), ([httpLoading, routerLoading]) => {
            if (httpLoading || routerLoading)
                this.startLoading();
            else
                this.stopLoading();
        });
    }
    ngOnDestroy() {
        this.interval.unsubscribe();
    }
    startLoading() {
        if (this.isLoading || !this.interval.closed)
            return;
        this.isLoading = true;
        this.progressLevel = 0;
        this.cdRef.detectChanges();
        this.interval = timer(0, this.intervalPeriod).subscribe(this.reportProgress);
        this.timer.unsubscribe();
    }
    stopLoading() {
        this.interval.unsubscribe();
        this.progressLevel = 100;
        this.isLoading = false;
        if (!this.timer.closed)
            return;
        this.timer = timer(this.stopDelay).subscribe(this.clearProgress);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoaderBarComponent, deps: [{ token: i1$1.Router }, { token: i0.ChangeDetectorRef }, { token: i2.SubscriptionService }, { token: i2.HttpWaitService }, { token: i2.RouterWaitService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: LoaderBarComponent, isStandalone: false, selector: "abp-loader-bar", inputs: { isLoading: "isLoading", containerClass: "containerClass", color: "color" }, providers: [SubscriptionService], ngImport: i0, template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow,
        }"
      ></div>
    </div>
  `, isInline: true, styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoaderBarComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-loader-bar', template: `
    <div id="abp-loader-bar" [ngClass]="containerClass" [class.is-loading]="isLoading">
      <div
        class="abp-progress"
        [class.progressing]="progressLevel"
        [style.width.vw]="progressLevel"
        [ngStyle]="{
          'background-color': color,
          'box-shadow': boxShadow,
        }"
      ></div>
    </div>
  `, providers: [SubscriptionService], styles: [".abp-loader-bar{left:0;opacity:0;position:fixed;top:0;transition:opacity .4s linear .4s;z-index:99999}.abp-loader-bar.is-loading{opacity:1;transition:none}.abp-loader-bar .abp-progress{height:3px;left:0;position:fixed;top:0}.abp-loader-bar .abp-progress.progressing{transition:width .4s ease}\n"] }]
        }], ctorParameters: () => [{ type: i1$1.Router }, { type: i0.ChangeDetectorRef }, { type: i2.SubscriptionService }, { type: i2.HttpWaitService }, { type: i2.RouterWaitService }], propDecorators: { isLoading: [{
                type: Input
            }], containerClass: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

class LoadingComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoadingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: LoadingComponent, isStandalone: false, selector: "abp-loading", ngImport: i0, template: `
    <div class="abp-loading">
      <i class="fa fa-spinner fa-pulse abp-spinner" aria-hidden="true"></i>
    </div>
  `, isInline: true, styles: [".abp-loading{position:absolute;width:100%;height:100%;top:0;left:0;z-index:1040}.abp-loading .abp-spinner{position:absolute;top:50%;left:50%;font-size:14px;-moz-transform:translateX(-50%) translateY(-50%);-o-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);-webkit-transform:translateX(-50%) translateY(-50%);transform:translate(-50%) translateY(-50%)}\n"], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoadingComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-loading', template: `
    <div class="abp-loading">
      <i class="fa fa-spinner fa-pulse abp-spinner" aria-hidden="true"></i>
    </div>
  `, encapsulation: ViewEncapsulation.None, styles: [".abp-loading{position:absolute;width:100%;height:100%;top:0;left:0;z-index:1040}.abp-loading .abp-spinner{position:absolute;top:50%;left:50%;font-size:14px;-moz-transform:translateX(-50%) translateY(-50%);-o-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);-webkit-transform:translateX(-50%) translateY(-50%);transform:translate(-50%) translateY(-50%)}\n"] }]
        }] });

class ConfirmationService {
    constructor(contentProjectionService) {
        this.contentProjectionService = contentProjectionService;
        this.confirmation$ = new ReplaySubject(1);
        this.clear = (status = Confirmation.Status.dismiss) => {
            this.confirmation$.next(null);
            this.status$.next(status);
        };
    }
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ConfirmationComponent, {
            confirmation$: this.confirmation$,
            clear: this.clear,
        }));
        setTimeout(() => {
            this.containerComponentRef.changeDetectorRef.detectChanges();
        }, 0);
    }
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    show(message, title, severity, options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        this.confirmation$.next({
            message,
            title,
            severity: severity || 'neutral',
            options,
        });
        this.status$ = new Subject();
        const { dismissible = true } = options;
        if (dismissible)
            this.listenToEscape();
        return this.status$;
    }
    listenToEscape() {
        fromEvent(document, 'keyup')
            .pipe(takeUntil(this.status$), debounceTime(150), filter((key) => key && key.key === 'Escape'))
            .subscribe(() => {
            this.clear();
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ConfirmationService, deps: [{ token: i2.ContentProjectionService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ConfirmationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ConfirmationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i2.ContentProjectionService }] });

const SUPPRESS_UNSAVED_CHANGES_WARNING = new InjectionToken('SUPPRESS_UNSAVED_CHANGES_WARNING');

class ModalRefService {
    constructor() {
        this.modalRefs = [];
    }
    register(modal) {
        this.modalRefs.push(modal);
    }
    unregister(modal) {
        const index = this.modalRefs.indexOf(modal);
        if (index > -1) {
            this.modalRefs.splice(index, 1);
        }
    }
    dismissAll(mode) {
        this.modalRefs.forEach(modal => modal.dismiss(mode));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalRefService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalRefService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalRefService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ModalComponent {
    get modalWindowRef() {
        return document.querySelector(`ngb-modal-window.${this.modalIdentifier}`);
    }
    get isFormDirty() {
        return Boolean(this.modalWindowRef?.querySelector('.ng-dirty'));
    }
    constructor() {
        this.confirmationService = inject(ConfirmationService);
        this.modal = inject(NgbModal);
        this.modalRefService = inject(ModalRefService);
        this.suppressUnsavedChangesWarningToken = inject(SUPPRESS_UNSAVED_CHANGES_WARNING, {
            optional: true,
        });
        this.destroyRef = inject(DestroyRef);
        this.visible = model(false);
        this.busy = input(false, {
            transform: (value) => {
                if (this.abpSubmit() && this.abpSubmit() instanceof ButtonComponent) {
                    this.abpSubmit().loading = value;
                }
                return value;
            },
        });
        this.options = input({ keyboard: true });
        this.suppressUnsavedChangesWarning = input(this.suppressUnsavedChangesWarningToken);
        this.modalContent = viewChild('modalContent');
        this.abpHeader = contentChild('abpHeader');
        this.abpBody = contentChild('abpBody');
        this.abpFooter = contentChild('abpFooter');
        this.abpSubmit = contentChild(ButtonComponent, { read: ButtonComponent });
        this.init = output();
        this.appear = output();
        this.disappear = output();
        this.isConfirmationOpen = false;
        this.modalIdentifier = `modal-${uuid()}`;
        effect(() => {
            this.toggle(this.visible());
        });
    }
    ngOnInit() {
        this.modalRefService.register(this);
    }
    dismiss(mode) {
        switch (mode) {
            case 'hard':
                this.visible.set(false);
                break;
            case 'soft':
                this.close();
                break;
            default:
                break;
        }
    }
    toggle(value) {
        this.visible.set(value);
        if (!value) {
            this.modalRef?.dismiss();
            this.disappear.emit();
            return;
        }
        setTimeout(() => this.listen(), 0);
        this.modalRef = this.modal.open(this.modalContent(), {
            size: 'md',
            centered: false,
            keyboard: false,
            scrollable: true,
            beforeDismiss: () => {
                if (!this.visible())
                    return true;
                this.close();
                return !this.visible();
            },
            ...this.options(),
            windowClass: `${this.options().windowClass || ''} ${this.modalIdentifier}`,
        });
        this.appear.emit();
    }
    ngOnDestroy() {
        this.modalRefService.unregister(this);
        this.toggle(false);
    }
    close() {
        if (this.busy())
            return;
        if (this.isFormDirty && !this.suppressUnsavedChangesWarning()) {
            if (this.isConfirmationOpen)
                return;
            this.isConfirmationOpen = true;
            this.confirmationService
                .warn('AbpUi::AreYouSureYouWantToCancelEditingWarningMessage', 'AbpUi::AreYouSure', {
                dismissible: false,
            })
                .subscribe((status) => {
                this.isConfirmationOpen = false;
                if (status === Confirmation.Status.confirm) {
                    this.visible.set(false);
                }
            });
        }
        else {
            this.visible.set(false);
        }
    }
    listen() {
        if (this.modalWindowRef) {
            fromEvent(this.modalWindowRef, 'keyup')
                .pipe(takeUntilDestroyed(this.destroyRef), debounceTime(150), filter((key) => key && key.key === 'Escape' && this.options().keyboard))
                .subscribe(() => this.close());
        }
        fromEvent(window, 'beforeunload')
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(event => {
            if (this.isFormDirty && !this.suppressUnsavedChangesWarning()) {
                event.preventDefault();
            }
        });
        this.init.emit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ModalComponent, isStandalone: false, selector: "abp-modal", inputs: { visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, busy: { classPropertyName: "busy", publicName: "busy", isSignal: true, isRequired: false, transformFunction: null }, options: { classPropertyName: "options", publicName: "options", isSignal: true, isRequired: false, transformFunction: null }, suppressUnsavedChangesWarning: { classPropertyName: "suppressUnsavedChangesWarning", publicName: "suppressUnsavedChangesWarning", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "visibleChange", init: "init", appear: "appear", disappear: "disappear" }, providers: [SubscriptionService], queries: [{ propertyName: "abpHeader", first: true, predicate: ["abpHeader"], descendants: true, isSignal: true }, { propertyName: "abpBody", first: true, predicate: ["abpBody"], descendants: true, isSignal: true }, { propertyName: "abpFooter", first: true, predicate: ["abpFooter"], descendants: true, isSignal: true }, { propertyName: "abpSubmit", first: true, predicate: ButtonComponent, descendants: true, read: ButtonComponent, isSignal: true }], viewQueries: [{ propertyName: "modalContent", first: true, predicate: ["modalContent"], descendants: true, isSignal: true }], ngImport: i0, template: "<ng-content></ng-content>\r\n\r\n<ng-template #modalContent let-modal>\r\n  @if (abpHeader()) {\r\n    <div id=\"abp-modal-header\" class=\"modal-header abp-modal-header\">\r\n      <ng-container *ngTemplateOutlet=\"abpHeader()\"></ng-container>\r\n      \u200B\r\n      <button\r\n        id=\"abp-modal-close-button\"\r\n        type=\"button\"\r\n        class=\"btn-sm btn-close\"\r\n        aria-label=\"Close\"\r\n        (click)=\"modal.dismiss()\"\r\n      ></button>\r\n    </div>\r\n  }\r\n  @if (abpBody()) {\r\n    <div id=\"abp-modal-body\" class=\"modal-body\">\r\n      <ng-container *ngTemplateOutlet=\"abpBody()\"></ng-container>\r\n    </div>\r\n  }\r\n  @if (abpFooter()) {\r\n    <div id=\"abp-modal-footer\" class=\"modal-footer\">\r\n      <ng-container *ngTemplateOutlet=\"abpFooter()\"></ng-container>\r\n    </div>\r\n  }\r\n</ng-template>\r\n", styles: [".modal.show{display:block!important}.modal-backdrop{opacity:.8}.modal::-webkit-scrollbar{width:7px}.modal::-webkit-scrollbar-track{background:#ddd}.modal::-webkit-scrollbar-thumb{background:#8a8686}.modal-dialog{z-index:1050}\n"], dependencies: [{ kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-modal', providers: [SubscriptionService], template: "<ng-content></ng-content>\r\n\r\n<ng-template #modalContent let-modal>\r\n  @if (abpHeader()) {\r\n    <div id=\"abp-modal-header\" class=\"modal-header abp-modal-header\">\r\n      <ng-container *ngTemplateOutlet=\"abpHeader()\"></ng-container>\r\n      \u200B\r\n      <button\r\n        id=\"abp-modal-close-button\"\r\n        type=\"button\"\r\n        class=\"btn-sm btn-close\"\r\n        aria-label=\"Close\"\r\n        (click)=\"modal.dismiss()\"\r\n      ></button>\r\n    </div>\r\n  }\r\n  @if (abpBody()) {\r\n    <div id=\"abp-modal-body\" class=\"modal-body\">\r\n      <ng-container *ngTemplateOutlet=\"abpBody()\"></ng-container>\r\n    </div>\r\n  }\r\n  @if (abpFooter()) {\r\n    <div id=\"abp-modal-footer\" class=\"modal-footer\">\r\n      <ng-container *ngTemplateOutlet=\"abpFooter()\"></ng-container>\r\n    </div>\r\n  }\r\n</ng-template>\r\n", styles: [".modal.show{display:block!important}.modal-backdrop{opacity:.8}.modal::-webkit-scrollbar{width:7px}.modal::-webkit-scrollbar-track{background:#ddd}.modal::-webkit-scrollbar-thumb{background:#8a8686}.modal-dialog{z-index:1050}\n"] }]
        }], ctorParameters: () => [] });

class ModalCloseDirective {
    constructor(modal) {
        this.modal = modal;
        if (!modal) {
            console.error('Please use abpClose within an abp-modal');
        }
    }
    onClick() {
        this.modal?.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalCloseDirective, deps: [{ token: ModalComponent, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: ModalCloseDirective, isStandalone: false, selector: "[abpClose]", host: { listeners: { "click": "onClick()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ModalCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: '[abpClose]',
                }]
        }], ctorParameters: () => [{ type: ModalComponent, decorators: [{
                    type: Optional
                }] }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class ToastComponent {
    constructor() {
        this.remove = new EventEmitter();
    }
    get severityClass() {
        if (!this.toast || !this.toast.severity)
            return '';
        return `abp-toast-${this.toast.severity}`;
    }
    get iconClass() {
        const { iconClass } = this.toast.options || {};
        if (iconClass) {
            return iconClass;
        }
        switch (this.toast.severity) {
            case 'success':
                return 'bi-check';
            case 'info':
                return 'bi-info-circle';
            case 'warning':
                return 'bi-exclamation-triangle';
            case 'error':
                return 'bi-shield-exclamation';
            default:
                return 'bi-exclamation-triangle';
        }
    }
    ngOnInit() {
        const { sticky, life } = this.toast.options || {};
        if (sticky)
            return;
        const timeout = life || 5000;
        setTimeout(() => {
            this.close();
        }, timeout);
    }
    close() {
        this.remove.emit(this.toast.options?.id);
    }
    tap() {
        if (this.toast.options?.tapToDismiss)
            this.close();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToastComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ToastComponent, isStandalone: false, selector: "abp-toast", inputs: { toast: "toast" }, outputs: { remove: "remove" }, ngImport: i0, template: "<div class=\"abp-toast\" [ngClass]=\"severityClass\" (click)=\"tap()\">\r\n  <div class=\"abp-toast-icon\">\r\n    <i class=\"bi icon\" [ngClass]=\"iconClass\" aria-hidden=\"true\"></i>\r\n  </div>\r\n  <div class=\"abp-toast-content\">\r\n    @if (toast.options?.closable) {\r\n      <button class=\"abp-toast-close-button\" (click)=\"close()\">\r\n        <i class=\"bi bi-x fs-4\" aria-hidden=\"true\"></i>\r\n      </button>\r\n    }\r\n    <div class=\"abp-toast-title\">\r\n      {{ toast.title | abpLocalization: toast.options?.titleLocalizationParams }}\r\n    </div>\r\n    <p\r\n      class=\"abp-toast-message\"\r\n      [innerHTML]=\"toast.message | abpLocalization: toast.options?.messageLocalizationParams\"\r\n    ></p>\r\n  </div>\r\n</div>\r\n", styles: [".abp-toast{display:grid;grid-template-columns:35px 1fr;gap:5px;margin:5px 0;padding:7px;width:350px;-webkit-user-select:none;user-select:none;z-index:9999;color:#fff;border-radius:8px;font-size:14px;box-shadow:0 0 20px #4c577d05;border:2px solid #f0f0f0;background-color:#f0f0f0;color:#000;box-shadow:0 0 10px -5px #0006;opacity:1}.abp-toast:hover{border:2px solid #e4e4e4;background-color:#e4e4e4;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-success{border:2px solid #4fbf67;background-color:#4fbf67;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-success:hover{border:2px solid rgb(69.1,187.4,94.45);background-color:#45bb5e;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-info{border:2px solid #438aa7;background-color:#438aa7;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-info:hover{border:2px solid rgb(63.65,131.1,158.65);background-color:#40839f;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-warning{border:2px solid #ff9f38;background-color:#ff9f38;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-warning:hover{border:2px solid rgb(255,151.4984924623,40.45);background-color:#ff9728;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-error{border:2px solid #c00d49;background-color:#c00d49;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-error:hover{border:2px solid rgb(182.4,12.35,69.35);background-color:#b60c45;box-shadow:0 0 15px -5px #0006}.abp-toast .abp-toast-icon{display:flex;align-items:center;justify-content:center}.abp-toast .abp-toast-icon .icon{font-size:32px}.abp-toast .abp-toast-content{position:relative;display:flex;align-self:center;flex-direction:column;word-break:break-word;padding-bottom:2px}.abp-toast .abp-toast-content .abp-toast-close-button{position:absolute;top:0;right:0;display:flex;align-items:center;justify-content:center;margin:0;padding:0 5px 0 0;width:25px;height:100%;border:none;border-radius:50%;background:transparent;color:inherit}.abp-toast .abp-toast-content .abp-toast-close-button:focus{outline:none}.abp-toast .abp-toast-content .abp-toast-title{margin:0;padding:0;font-size:1rem;font-weight:600}.abp-toast .abp-toast-content .abp-toast-message{margin:0;padding:0;max-width:240px}\n"], dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-toast', template: "<div class=\"abp-toast\" [ngClass]=\"severityClass\" (click)=\"tap()\">\r\n  <div class=\"abp-toast-icon\">\r\n    <i class=\"bi icon\" [ngClass]=\"iconClass\" aria-hidden=\"true\"></i>\r\n  </div>\r\n  <div class=\"abp-toast-content\">\r\n    @if (toast.options?.closable) {\r\n      <button class=\"abp-toast-close-button\" (click)=\"close()\">\r\n        <i class=\"bi bi-x fs-4\" aria-hidden=\"true\"></i>\r\n      </button>\r\n    }\r\n    <div class=\"abp-toast-title\">\r\n      {{ toast.title | abpLocalization: toast.options?.titleLocalizationParams }}\r\n    </div>\r\n    <p\r\n      class=\"abp-toast-message\"\r\n      [innerHTML]=\"toast.message | abpLocalization: toast.options?.messageLocalizationParams\"\r\n    ></p>\r\n  </div>\r\n</div>\r\n", styles: [".abp-toast{display:grid;grid-template-columns:35px 1fr;gap:5px;margin:5px 0;padding:7px;width:350px;-webkit-user-select:none;user-select:none;z-index:9999;color:#fff;border-radius:8px;font-size:14px;box-shadow:0 0 20px #4c577d05;border:2px solid #f0f0f0;background-color:#f0f0f0;color:#000;box-shadow:0 0 10px -5px #0006;opacity:1}.abp-toast:hover{border:2px solid #e4e4e4;background-color:#e4e4e4;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-success{border:2px solid #4fbf67;background-color:#4fbf67;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-success:hover{border:2px solid rgb(69.1,187.4,94.45);background-color:#45bb5e;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-info{border:2px solid #438aa7;background-color:#438aa7;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-info:hover{border:2px solid rgb(63.65,131.1,158.65);background-color:#40839f;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-warning{border:2px solid #ff9f38;background-color:#ff9f38;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-warning:hover{border:2px solid rgb(255,151.4984924623,40.45);background-color:#ff9728;box-shadow:0 0 15px -5px #0006}.abp-toast.abp-toast-error{border:2px solid #c00d49;background-color:#c00d49;color:#fff;box-shadow:0 0 10px -5px #0006}.abp-toast.abp-toast-error:hover{border:2px solid rgb(182.4,12.35,69.35);background-color:#b60c45;box-shadow:0 0 15px -5px #0006}.abp-toast .abp-toast-icon{display:flex;align-items:center;justify-content:center}.abp-toast .abp-toast-icon .icon{font-size:32px}.abp-toast .abp-toast-content{position:relative;display:flex;align-self:center;flex-direction:column;word-break:break-word;padding-bottom:2px}.abp-toast .abp-toast-content .abp-toast-close-button{position:absolute;top:0;right:0;display:flex;align-items:center;justify-content:center;margin:0;padding:0 5px 0 0;width:25px;height:100%;border:none;border-radius:50%;background:transparent;color:inherit}.abp-toast .abp-toast-content .abp-toast-close-button:focus{outline:none}.abp-toast .abp-toast-content .abp-toast-title{margin:0;padding:0;font-size:1rem;font-weight:600}.abp-toast .abp-toast-content .abp-toast-message{margin:0;padding:0;max-width:240px}\n"] }]
        }], propDecorators: { toast: [{
                type: Input
            }], remove: [{
                type: Output
            }] } });

class ToastContainerComponent {
    constructor() {
        this.toasts = [];
        this.right = '30px';
        this.defaultRight = '30px';
        this.defaultMobileRight = '0';
        this.bottom = '30px';
    }
    ngOnInit() {
        this.setDefaultRight();
        this.toasts$.subscribe(toasts => {
            this.toasts = this.toastKey
                ? toasts.filter(t => {
                    return t.options && t.options.containerKey !== this.toastKey;
                })
                : toasts;
        });
    }
    onWindowResize() {
        this.setDefaultRight();
    }
    setDefaultRight() {
        const screenWidth = window.innerWidth;
        if (screenWidth < 768 && this.right == this.defaultRight) {
            this.right = this.defaultMobileRight;
        }
    }
    trackByFunc(index, toast) {
        if (!toast)
            return null;
        return toast.options?.id;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToastContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ToastContainerComponent, isStandalone: false, selector: "abp-toast-container", inputs: { top: "top", right: "right", bottom: "bottom", left: "left", toastKey: "toastKey" }, host: { listeners: { "window:resize": "onWindowResize($event)" } }, ngImport: i0, template: "<div\r\n  class=\"abp-toast-container\"\r\n  [style.top]=\"top || 'auto'\"\r\n  [style.right]=\"right || 'auto'\"\r\n  [style.bottom]=\"bottom || 'auto'\"\r\n  [style.left]=\"left || 'auto'\"\r\n  [style.display]=\"toasts.length ? 'flex' : 'none'\"\r\n  [@toastInOut]=\"toasts.length\"\r\n>\r\n  @for (toast of toasts; track toast.options?.id) {\r\n    <abp-toast\r\n      [toast]=\"toast\"\r\n      (remove)=\"remove($event)\"\r\n    ></abp-toast>\r\n  }\r\n</div>\r\n", styles: [".abp-toast-container{position:fixed;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;min-width:350px;min-height:80px;z-index:1900}.abp-toast-container.new-on-top{flex-direction:column-reverse}@media only screen and (max-width: 768px){.abp-toast-container{min-width:100%}}\n"], dependencies: [{ kind: "component", type: ToastComponent, selector: "abp-toast", inputs: ["toast"], outputs: ["remove"] }], animations: [toastInOut] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToastContainerComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-toast-container', animations: [toastInOut], template: "<div\r\n  class=\"abp-toast-container\"\r\n  [style.top]=\"top || 'auto'\"\r\n  [style.right]=\"right || 'auto'\"\r\n  [style.bottom]=\"bottom || 'auto'\"\r\n  [style.left]=\"left || 'auto'\"\r\n  [style.display]=\"toasts.length ? 'flex' : 'none'\"\r\n  [@toastInOut]=\"toasts.length\"\r\n>\r\n  @for (toast of toasts; track toast.options?.id) {\r\n    <abp-toast\r\n      [toast]=\"toast\"\r\n      (remove)=\"remove($event)\"\r\n    ></abp-toast>\r\n  }\r\n</div>\r\n", styles: [".abp-toast-container{position:fixed;display:flex;flex-direction:column;align-items:center;justify-content:flex-end;min-width:350px;min-height:80px;z-index:1900}.abp-toast-container.new-on-top{flex-direction:column-reverse}@media only screen and (max-width: 768px){.abp-toast-container{min-width:100%}}\n"] }]
        }], propDecorators: { top: [{
                type: Input
            }], right: [{
                type: Input
            }], bottom: [{
                type: Input
            }], left: [{
                type: Input
            }], toastKey: [{
                type: Input
            }], onWindowResize: [{
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

/**
 * @deprecated use ShowPasswordDirective directive
 * https://abp.io/docs/latest/framework/ui/angular/show-password-directive
 */
class PasswordComponent extends AbstractNgModelComponent {
    toggleFieldTextType() {
        this.fieldTextType = !this.fieldTextType;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PasswordComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: PasswordComponent, isStandalone: true, selector: "abp-password", inputs: { inputId: "inputId", formControlName: "formControlName" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => PasswordComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: "<div class=\"input-group\" validationTarget>\r\n  <input\r\n    [type]=\"fieldTextType ? 'text' : 'password'\"\r\n    class=\"form-control\"\r\n    [id]=\"inputId\"\r\n    [(ngModel)]=\"value\"\r\n  />\r\n\r\n  <button class=\"btn btn-secondary\" type=\"button\" (click)=\"toggleFieldTextType()\">\r\n    <i\r\n      class=\"fa\"\r\n      aria-hidden=\"true\"\r\n      [ngClass]=\"{\r\n        'fa-eye-slash': !fieldTextType,\r\n        'fa-eye': fieldTextType\r\n      }\"\r\n    ></i>\r\n  </button>\r\n</div>\r\n", dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PasswordComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-password', imports: [CommonModule, FormsModule], providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => PasswordComponent),
                            multi: true,
                        },
                    ], template: "<div class=\"input-group\" validationTarget>\r\n  <input\r\n    [type]=\"fieldTextType ? 'text' : 'password'\"\r\n    class=\"form-control\"\r\n    [id]=\"inputId\"\r\n    [(ngModel)]=\"value\"\r\n  />\r\n\r\n  <button class=\"btn btn-secondary\" type=\"button\" (click)=\"toggleFieldTextType()\">\r\n    <i\r\n      class=\"fa\"\r\n      aria-hidden=\"true\"\r\n      [ngClass]=\"{\r\n        'fa-eye-slash': !fieldTextType,\r\n        'fa-eye': fieldTextType\r\n      }\"\r\n    ></i>\r\n  </button>\r\n</div>\r\n" }]
        }], propDecorators: { inputId: [{
                type: Input
            }], formControlName: [{
                type: Input
            }] } });

class CardBodyComponent {
    constructor() {
        this.componentClass = 'card-body';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: CardBodyComponent, isStandalone: false, selector: "abp-card-body", inputs: { cardBodyClass: "cardBodyClass", cardBodyStyle: "cardBodyStyle" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: ` <div [ngClass]="cardBodyClass" [ngStyle]="cardBodyStyle">
    <ng-content></ng-content>
  </div>`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardBodyComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-card-body',
                    template: ` <div [ngClass]="cardBodyClass" [ngStyle]="cardBodyStyle">
    <ng-content></ng-content>
  </div>`,
                }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardBodyClass: [{
                type: Input
            }], cardBodyStyle: [{
                type: Input
            }] } });

class CardComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: CardComponent, isStandalone: false, selector: "abp-card", inputs: { cardClass: "cardClass", cardStyle: "cardStyle" }, ngImport: i0, template: ` <div class="card" [ngClass]="cardClass" [ngStyle]="cardStyle">
    <ng-content></ng-content>
  </div>`, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-card',
                    template: ` <div class="card" [ngClass]="cardClass" [ngStyle]="cardStyle">
    <ng-content></ng-content>
  </div>`,
                }]
        }], propDecorators: { cardClass: [{
                type: Input
            }], cardStyle: [{
                type: Input
            }] } });

class CardHeaderComponent {
    constructor() {
        this.componentClass = 'card-header';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: CardHeaderComponent, isStandalone: false, selector: "abp-card-header", inputs: { cardHeaderClass: "cardHeaderClass", cardHeaderStyle: "cardHeaderStyle" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: `
    <div [ngClass]="cardHeaderClass" [ngStyle]="cardHeaderStyle">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardHeaderComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-card-header', template: `
    <div [ngClass]="cardHeaderClass" [ngStyle]="cardHeaderStyle">
      <ng-content></ng-content>
    </div>
  ` }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardHeaderClass: [{
                type: Input
            }], cardHeaderStyle: [{
                type: Input
            }] } });

class CardFooterComponent {
    constructor() {
        this.componentClass = 'card-footer';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: CardFooterComponent, isStandalone: false, selector: "abp-card-footer", inputs: { cardFooterStyle: "cardFooterStyle", cardFooterClass: "cardFooterClass" }, host: { properties: { "class": "this.componentClass" } }, ngImport: i0, template: `
    <div [ngStyle]="cardFooterStyle" [ngClass]="cardFooterClass">
      <ng-content></ng-content>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardFooterComponent, decorators: [{
            type: Component,
            args: [{ standalone: false, selector: 'abp-card-footer', template: `
    <div [ngStyle]="cardFooterStyle" [ngClass]="cardFooterClass">
      <ng-content></ng-content>
    </div>
  ` }]
        }], propDecorators: { componentClass: [{
                type: HostBinding,
                args: ['class']
            }], cardFooterStyle: [{
                type: Input
            }], cardFooterClass: [{
                type: Input
            }] } });

class CardTitleDirective {
    constructor() {
        this.directiveClass = 'card-title';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: CardTitleDirective, isStandalone: false, selector: "abp-card-title, [abp-card-title], [abpCardTitle]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: `abp-card-title, [abp-card-title], [abpCardTitle]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardSubtitleDirective {
    constructor() {
        this.directiveClass = 'card-subtitle';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardSubtitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: CardSubtitleDirective, isStandalone: false, selector: "abp-card-subtitle, [abp-card-subtitle], [abpCardSubtitle]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardSubtitleDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: `abp-card-subtitle, [abp-card-subtitle], [abpCardSubtitle]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardImgTopDirective {
    constructor() {
        this.directiveClass = 'card-img-top';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardImgTopDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: CardImgTopDirective, isStandalone: false, selector: "abp-card-img-top, [abp-card-img-top], [abpCardImgTop]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardImgTopDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: `abp-card-img-top, [abp-card-img-top], [abpCardImgTop]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class CardHeaderDirective {
    constructor() {
        this.directiveClass = 'card-header';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardHeaderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: CardHeaderDirective, isStandalone: false, selector: "abp-card-header, [abp-card-header], [abpCardHeader]", host: { properties: { "class": "this.directiveClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: `abp-card-header, [abp-card-header], [abpCardHeader]`,
                }]
        }], propDecorators: { directiveClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

const declarationsWithExports$1 = [
    CardComponent,
    CardBodyComponent,
    CardHeaderComponent,
    CardFooterComponent,
    CardTitleDirective,
    CardSubtitleDirective,
    CardImgTopDirective,
    CardHeaderDirective,
];
class CardModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: CardModule, declarations: [CardComponent,
            CardBodyComponent,
            CardHeaderComponent,
            CardFooterComponent,
            CardTitleDirective,
            CardSubtitleDirective,
            CardImgTopDirective,
            CardHeaderDirective], imports: [CommonModule], exports: [CardComponent,
            CardBodyComponent,
            CardHeaderComponent,
            CardFooterComponent,
            CardTitleDirective,
            CardSubtitleDirective,
            CardImgTopDirective,
            CardHeaderDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...declarationsWithExports$1],
                    imports: [CommonModule],
                    exports: [...declarationsWithExports$1],
                }]
        }] });

class FormCheckboxComponent extends AbstractNgModelComponent {
    constructor() {
        super(...arguments);
        this.labelClass = 'form-check-label';
        this.checkboxClass = 'form-check-input';
        this.checkboxReadonly = false;
        this.checkboxBlur = new EventEmitter();
        this.checkboxFocus = new EventEmitter();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: FormCheckboxComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: FormCheckboxComponent, isStandalone: false, selector: "abp-checkbox", inputs: { label: "label", labelClass: "labelClass", checkboxId: "checkboxId", checkboxStyle: "checkboxStyle", checkboxClass: "checkboxClass", checkboxReadonly: "checkboxReadonly" }, outputs: { checkboxBlur: "checkboxBlur", checkboxFocus: "checkboxFocus" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FormCheckboxComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: `
    <div class="mb-3">
      <input
        type="checkbox"
        [(ngModel)]="value"
        [id]="checkboxId"
        [readonly]="checkboxReadonly"
        [ngClass]="checkboxClass"
        [ngStyle]="checkboxStyle"
        (blur)="checkboxBlur.next()"
        (focus)="checkboxFocus.next()"
      />
      @if (label) {
        <label [ngClass]="labelClass" [for]="checkboxId">
          {{ label | abpLocalization }}
        </label>
      }
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2$1.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: FormCheckboxComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-checkbox',
                    template: `
    <div class="mb-3">
      <input
        type="checkbox"
        [(ngModel)]="value"
        [id]="checkboxId"
        [readonly]="checkboxReadonly"
        [ngClass]="checkboxClass"
        [ngStyle]="checkboxStyle"
        (blur)="checkboxBlur.next()"
        (focus)="checkboxFocus.next()"
      />
      @if (label) {
        <label [ngClass]="labelClass" [for]="checkboxId">
          {{ label | abpLocalization }}
        </label>
      }
    </div>
  `,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FormCheckboxComponent),
                            multi: true,
                        },
                    ],
                }]
        }], propDecorators: { label: [{
                type: Input
            }], labelClass: [{
                type: Input
            }], checkboxId: [{
                type: Input
            }], checkboxStyle: [{
                type: Input
            }], checkboxClass: [{
                type: Input
            }], checkboxReadonly: [{
                type: Input
            }], checkboxBlur: [{
                type: Output
            }], checkboxFocus: [{
                type: Output
            }] } });

class FormInputComponent extends AbstractNgModelComponent {
    constructor() {
        super(...arguments);
        this.inputReadonly = false;
        this.label = '';
        this.labelClass = 'form-label';
        this.inputPlaceholder = '';
        this.inputClass = 'form-control';
        this.formBlur = new EventEmitter();
        this.formFocus = new EventEmitter();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: FormInputComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: FormInputComponent, isStandalone: false, selector: "abp-form-input", inputs: { inputId: "inputId", inputReadonly: "inputReadonly", label: "label", labelClass: "labelClass", inputPlaceholder: "inputPlaceholder", inputStyle: "inputStyle", inputClass: "inputClass" }, outputs: { formBlur: "formBlur", formFocus: "formFocus" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => FormInputComponent),
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0, template: `
    <div class="mb-3">
      @if (label) {
        <label [ngClass]="labelClass" [for]="inputId">
          {{ label | abpLocalization }}
        </label>
      }
      <input
        type="text"
        [id]="inputId"
        [placeholder]="inputPlaceholder"
        [readonly]="inputReadonly"
        [ngClass]="inputClass"
        [ngStyle]="inputStyle"
        (blur)="formBlur.next()"
        (focus)="formFocus.next()"
        [(ngModel)]="value"
      />
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: FormInputComponent, decorators: [{
            type: Component,
            args: [{
                    standalone: false,
                    selector: 'abp-form-input',
                    template: `
    <div class="mb-3">
      @if (label) {
        <label [ngClass]="labelClass" [for]="inputId">
          {{ label | abpLocalization }}
        </label>
      }
      <input
        type="text"
        [id]="inputId"
        [placeholder]="inputPlaceholder"
        [readonly]="inputReadonly"
        [ngClass]="inputClass"
        [ngStyle]="inputStyle"
        (blur)="formBlur.next()"
        (focus)="formFocus.next()"
        [(ngModel)]="value"
      />
    </div>
  `,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => FormInputComponent),
                            multi: true,
                        },
                    ],
                }]
        }], propDecorators: { inputId: [{
                type: Input
            }], inputReadonly: [{
                type: Input
            }], label: [{
                type: Input
            }], labelClass: [{
                type: Input
            }], inputPlaceholder: [{
                type: Input
            }], inputStyle: [{
                type: Input
            }], inputClass: [{
                type: Input
            }], formBlur: [{
                type: Output
            }], formFocus: [{
                type: Output
            }] } });

class InternetConnectionStatusComponent {
    constructor() {
        this.internetConnectionService = inject(InternetConnectionService);
        this.isOnline = this.internetConnectionService.networkStatus;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: InternetConnectionStatusComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: InternetConnectionStatusComponent, isStandalone: true, selector: "abp-internet-status", ngImport: i0, template: `
    @if (!isOnline()) {
      <div class="status-icon">
        <i
          ngbTooltip="{{ 'AbpUi::InternetConnectionInfo' | abpLocalization }}"
          container="body"
          placement="left-top"
          class="fa fa-wifi text-blinking blink"
        >
        </i>
      </div>
    }
  `, isInline: true, styles: [".blink{animation:blinker .9s cubic-bezier(.5,0,1,1) infinite alternate}@keyframes blinker{0%{color:#c1c1c1}70%{color:#fa2379}to{color:#fa2379}}.text-blinking{font-size:30px}.status-icon{position:fixed;z-index:999999;top:50%;left:50%;width:30px;text-align:center;margin-left:-15px;margin-top:-15px;translate:transform(-50%,-50%)}\n"], dependencies: [{ kind: "ngmodule", type: LocalizationModule }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }, { kind: "directive", type: NgbTooltip, selector: "[ngbTooltip]", inputs: ["animation", "autoClose", "placement", "popperOptions", "triggers", "positionTarget", "container", "disableTooltip", "tooltipClass", "tooltipContext", "openDelay", "closeDelay", "ngbTooltip"], outputs: ["shown", "hidden"], exportAs: ["ngbTooltip"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: InternetConnectionStatusComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-internet-status', imports: [LocalizationModule, NgbTooltip], template: `
    @if (!isOnline()) {
      <div class="status-icon">
        <i
          ngbTooltip="{{ 'AbpUi::InternetConnectionInfo' | abpLocalization }}"
          container="body"
          placement="left-top"
          class="fa fa-wifi text-blinking blink"
        >
        </i>
      </div>
    }
  `, styles: [".blink{animation:blinker .9s cubic-bezier(.5,0,1,1) infinite alternate}@keyframes blinker{0%{color:#c1c1c1}70%{color:#fa2379}to{color:#fa2379}}.text-blinking{font-size:30px}.status-icon{position:fixed;z-index:999999;top:50%;left:50%;width:30px;text-align:center;margin-left:-15px;margin-top:-15px;translate:transform(-50%,-50%)}\n"] }]
        }] });

class SpinnerComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: SpinnerComponent, isStandalone: true, selector: "abp-spinner", ngImport: i0, template: `
    <div class="d-flex justify-content-center align-items-center border-top" style="height: 62px">
      <div class="spinner-border" role="status" id="loading">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>
  `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-spinner',
                    standalone: true,
                    template: `
    <div class="d-flex justify-content-center align-items-center border-top" style="height: 62px">
      <div class="spinner-border" role="status" id="loading">
        <span class="visually-hidden">Loading...</span>
      </div>
    </div>
  `,
                }]
        }] });

class EllipsisDirective {
    get inlineClass() {
        return this.enabled && this.width;
    }
    get class() {
        return this.enabled && !this.width;
    }
    get maxWidth() {
        return this.enabled && this.width ? this.width || '170px' : undefined;
    }
    constructor(cdRef, elRef) {
        this.cdRef = cdRef;
        this.elRef = elRef;
        this.enabled = true;
    }
    ngAfterViewInit() {
        this.title = this.title || this.elRef.nativeElement.innerText;
        this.cdRef.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: EllipsisDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: EllipsisDirective, isStandalone: true, selector: "[abpEllipsis]", inputs: { width: ["abpEllipsis", "width"], title: "title", enabled: ["abpEllipsisEnabled", "enabled"] }, host: { properties: { "title": "this.title", "class.abp-ellipsis-inline": "this.inlineClass", "class.abp-ellipsis": "this.class", "style.max-width": "this.maxWidth" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: EllipsisDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpEllipsis]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }], propDecorators: { width: [{
                type: Input,
                args: ['abpEllipsis']
            }], title: [{
                type: HostBinding,
                args: ['title']
            }, {
                type: Input
            }], enabled: [{
                type: Input,
                args: ['abpEllipsisEnabled']
            }], inlineClass: [{
                type: HostBinding,
                args: ['class.abp-ellipsis-inline']
            }], class: [{
                type: HostBinding,
                args: ['class.abp-ellipsis']
            }], maxWidth: [{
                type: HostBinding,
                args: ['style.max-width']
            }] } });

class LoadingDirective {
    get loading() {
        return this._loading;
    }
    set loading(newValue) {
        setTimeout(() => {
            if (!newValue && this.timerSubscription) {
                this.timerSubscription.unsubscribe();
                this.timerSubscription = null;
                this._loading = newValue;
                if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                return;
            }
            this.timerSubscription = timer(this.delay)
                .pipe(take(1))
                .subscribe(() => {
                if (!this.componentRef) {
                    this.componentRef = this.cdRes
                        .resolveComponentFactory(LoadingComponent)
                        .create(this.injector);
                }
                if (newValue && !this.rootNode) {
                    this.rootNode = this.componentRef.hostView.rootNodes[0];
                    this.targetElement?.appendChild(this.rootNode);
                }
                else if (this.rootNode) {
                    this.renderer.removeChild(this.rootNode.parentElement, this.rootNode);
                    this.rootNode = null;
                }
                this._loading = newValue;
                this.timerSubscription = null;
            });
        }, 0);
    }
    constructor(elRef, vcRef, cdRes, injector, renderer) {
        this.elRef = elRef;
        this.vcRef = vcRef;
        this.cdRes = cdRes;
        this.injector = injector;
        this.renderer = renderer;
        this.position = 'relative';
        this.delay = 0;
        this.rootNode = null;
        this.timerSubscription = null;
    }
    ngOnInit() {
        if (!this.targetElement) {
            const { offsetHeight, offsetWidth } = this.elRef.nativeElement;
            if (!offsetHeight && !offsetWidth && this.elRef.nativeElement.children.length) {
                this.targetElement = this.elRef.nativeElement.children[0];
            }
            else {
                this.targetElement = this.elRef.nativeElement;
            }
        }
    }
    ngOnDestroy() {
        if (this.timerSubscription) {
            this.timerSubscription.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoadingDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }, { token: i0.Injector }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: LoadingDirective, isStandalone: false, selector: "[abpLoading]", inputs: { loading: ["abpLoading", "loading"], targetElement: ["abpLoadingTargetElement", "targetElement"], delay: ["abpLoadingDelay", "delay"] }, host: { properties: { "style.position": "this.position" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: LoadingDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: false,
                    selector: '[abpLoading]',
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Injector }, { type: i0.Renderer2 }], propDecorators: { position: [{
                type: HostBinding,
                args: ['style.position']
            }], loading: [{
                type: Input,
                args: ['abpLoading']
            }], targetElement: [{
                type: Input,
                args: ['abpLoadingTargetElement']
            }], delay: [{
                type: Input,
                args: ['abpLoadingDelay']
            }] } });

class NgxDatatableDefaultDirective {
    get classes() {
        return `ngx-datatable ${this.class}`;
    }
    constructor(table, document) {
        this.table = table;
        this.document = document;
        this.subscription = new Subscription();
        this.resizeDiff = 0;
        this.class = 'material bordered';
        this.table.columnMode = ColumnMode.force;
        this.table.footerHeight = 50;
        this.table.headerHeight = 50;
        this.table.rowHeight = 'auto';
        this.table.scrollbarH = true;
        this.table.virtualization = false;
    }
    fixHorizontalGap(scroller) {
        const { body, documentElement } = this.document;
        if (documentElement.scrollHeight !== documentElement.clientHeight) {
            if (this.resizeDiff === 0) {
                this.resizeDiff = window.innerWidth - body.offsetWidth;
                scroller.scrollWidth -= this.resizeDiff;
            }
        }
        else {
            scroller.scrollWidth += this.resizeDiff;
            this.resizeDiff = 0;
        }
    }
    fixStyleOnWindowResize() {
        // avoided @HostListener('window:resize') in favor of performance
        const subscription = fromEvent(window, 'resize')
            .pipe(debounceTime(500))
            .subscribe(() => {
            const { scroller } = this.table.bodyComponent;
            if (!scroller)
                return;
            this.fixHorizontalGap(scroller);
        });
        this.subscription.add(subscription);
    }
    ngAfterViewInit() {
        this.fixStyleOnWindowResize();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NgxDatatableDefaultDirective, deps: [{ token: i1$2.DatatableComponent }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: NgxDatatableDefaultDirective, isStandalone: true, selector: "ngx-datatable[default]", inputs: { class: "class" }, host: { properties: { "class": "this.classes" } }, exportAs: ["ngxDatatableDefault"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NgxDatatableDefaultDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'ngx-datatable[default]',
                    standalone: true,
                    exportAs: 'ngxDatatableDefault',
                }]
        }], ctorParameters: () => [{ type: i1$2.DatatableComponent }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }], propDecorators: { class: [{
                type: Input
            }], classes: [{
                type: HostBinding,
                args: ['class']
            }] } });

const defaultNgxDatatableMessages = {
    emptyMessage: 'AbpUi::NoDataAvailableInDatatable',
    errorMessage: 'AbpUi::ErrorLoadingDatatable',
    totalMessage: 'AbpUi::Total',
    selectedMessage: 'AbpUi::Selected',
};
const NGX_DATATABLE_MESSAGES = new InjectionToken('NGX_DATATABLE_MESSAGES');

class NgxDatatableListDirective {
    constructor() {
        this.table = inject(DatatableComponent);
        this.cdRef = inject(ChangeDetectorRef);
        this.destroyRef = inject(DestroyRef);
        this.localizationService = inject(LocalizationService);
        this.ngxDatatableMessages = inject(NGX_DATATABLE_MESSAGES, { optional: true });
        this.viewContainerRef = inject(ViewContainerRef);
        this.renderer = inject(Renderer2);
        this.setInitialValues();
    }
    ngDoCheck() {
        this.refreshPageIfDataExist();
    }
    ngOnInit() {
        this.subscribeToPage();
        this.subscribeToSort();
        this.subscribeToRequestStatus();
    }
    ngOnChanges({ list }) {
        this.subscribeToQuery();
        if (!list.firstChange)
            return;
        const { maxResultCount, page } = list.currentValue;
        this.table.limit = maxResultCount;
        this.table.offset = page;
    }
    subscribeToRequestStatus() {
        const requestStatus$ = this.list.requestStatus$.pipe(distinctUntilChanged());
        const { emptyMessage, errorMessage } = this.ngxDatatableMessages || defaultNgxDatatableMessages;
        requestStatus$.subscribe(status => {
            this.table.loadingIndicator = false;
            if (status === 'idle') {
                return;
            }
            if (status === 'loading') {
                this.table.messages.emptyMessage = undefined;
                this.table.loadingIndicator = true;
                this.cdRef.detectChanges();
                this.updateLoadingIndicator();
                return;
            }
            if (status === 'error') {
                this.table.messages.emptyMessage = this.localizationService.instant(errorMessage);
                this.viewContainerRef.clear();
                this.cdRef.markForCheck();
            }
            if (status === 'success') {
                this.table.messages.emptyMessage = this.localizationService.instant(emptyMessage);
                this.viewContainerRef.clear();
            }
        });
    }
    updateLoadingIndicator() {
        const body = this.table.element.querySelector('datatable-body');
        const progress = this.table.element.querySelector('datatable-progress');
        if (!body) {
            return;
        }
        if (progress) {
            this.replaceLoadingIndicator(body, progress);
        }
    }
    replaceLoadingIndicator(parent, placeholder) {
        this.viewContainerRef.clear();
        const spinnerRef = this.viewContainerRef.createComponent(SpinnerComponent);
        const spinnerElement = spinnerRef.location.nativeElement;
        this.renderer.insertBefore(parent, spinnerElement, placeholder);
        this.renderer.removeChild(parent, placeholder);
    }
    setInitialValues() {
        this.table.externalPaging = true;
        this.table.externalSorting = true;
        const { selectedMessage, totalMessage } = this.ngxDatatableMessages || defaultNgxDatatableMessages;
        this.table.messages = {
            totalMessage: this.localizationService.instant(totalMessage),
            selectedMessage: this.localizationService.instant(selectedMessage),
        };
    }
    subscribeToSort() {
        this.table.sort
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(({ sorts: [{ prop, dir }] }) => {
            if (prop === this.list.sortKey && this.list.sortOrder === 'desc') {
                this.list.sortKey = '';
                this.list.sortOrder = '';
                this.table.sorts = [];
                this.cdRef.detectChanges();
            }
            else {
                this.list.sortKey = prop;
                this.list.sortOrder = dir;
            }
        });
    }
    subscribeToPage() {
        this.table.page.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(({ offset }) => {
            this.setTablePage(offset);
        });
    }
    subscribeToQuery() {
        this.list.query$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
            const offset = this.list.page;
            if (this.table.offset !== offset)
                this.table.offset = offset;
        });
    }
    setTablePage(pageNum) {
        this.list.page = pageNum;
        this.table.offset = pageNum;
    }
    refreshPageIfDataExist() {
        if (this.table.rows?.length < 1 && this.table.count > 0) {
            let maxPage = Math.floor(Number(this.table.count / this.list.maxResultCount));
            if (this.table.count < this.list.maxResultCount) {
                this.setTablePage(0);
                return;
            }
            if (this.table.count % this.list.maxResultCount === 0) {
                maxPage -= 1;
            }
            if (this.list.page < maxPage) {
                this.setTablePage(this.list.page);
                return;
            }
            this.setTablePage(maxPage);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NgxDatatableListDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: NgxDatatableListDirective, isStandalone: true, selector: "ngx-datatable[list]", inputs: { list: "list" }, exportAs: ["ngxDatatableList"], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NgxDatatableListDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'ngx-datatable[list]',
                    standalone: true,
                    exportAs: 'ngxDatatableList',
                }]
        }], ctorParameters: () => [], propDecorators: { list: [{
                type: Input
            }] } });

class AbpVisibleDirective {
    set abpVisible(value) {
        this.condition$ = checkType(value);
        this.subscribeToCondition();
    }
    constructor(viewContainerRef, templateRef) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.condition$ = of(false);
    }
    ngOnInit() {
        this.updateVisibility();
    }
    ngOnDestroy() {
        this.conditionSubscription?.unsubscribe();
    }
    subscribeToCondition() {
        this.conditionSubscription = this.condition$.subscribe(value => {
            this.isVisible = value;
            this.updateVisibility();
        });
    }
    updateVisibility() {
        this.viewContainerRef.clear();
        // it should be false not falsy
        if (this.isVisible === false) {
            return;
        }
        this.viewContainerRef.createEmbeddedView(this.templateRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpVisibleDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: AbpVisibleDirective, isStandalone: true, selector: "[abpVisible]", inputs: { abpVisible: "abpVisible" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpVisibleDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[abpVisible]',
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }], propDecorators: { abpVisible: [{
                type: Input
            }] } });
function checkType(value) {
    if (value instanceof Promise) {
        return from(value);
    }
    else if (value instanceof Observable) {
        return value;
    }
    else if (typeof value === 'boolean') {
        return of(value);
    }
    else if (value === undefined || value === null) {
        return of(true);
    }
    else {
        return EMPTY;
    }
}

class DisabledDirective {
    constructor(ngControl) {
        this.ngControl = ngControl;
        this.abpDisabled = false;
    }
    // Related issue: https://github.com/angular/angular/issues/35330
    ngOnChanges({ abpDisabled }) {
        if (this.ngControl.control && abpDisabled) {
            this.ngControl.control[abpDisabled.currentValue ? 'disable' : 'enable']();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DisabledDirective, deps: [{ token: i2$1.NgControl, host: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: DisabledDirective, isStandalone: true, selector: "[abpDisabled]", inputs: { abpDisabled: "abpDisabled" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DisabledDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpDisabled]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i2$1.NgControl, decorators: [{
                    type: Host
                }] }], propDecorators: { abpDisabled: [{
                type: Input
            }] } });

var eFormComponets;
(function (eFormComponets) {
    eFormComponets["FormInputComponent"] = "FormInputComponent";
    eFormComponets["FormCheckboxComponent"] = "FormCheckboxComponent";
})(eFormComponets || (eFormComponets = {}));

class DocumentDirHandlerService {
    constructor(injector) {
        this.injector = injector;
        this.dir = new BehaviorSubject('ltr');
        this.dir$ = this.dir.asObservable();
        this.listenToLanguageChanges();
    }
    listenToLanguageChanges() {
        const l10n = this.injector.get(LocalizationService);
        // will always listen, no need to unsubscribe
        l10n.currentLang$.pipe(map(locale => getLocaleDirection(locale))).subscribe(dir => {
            this.dir.next(dir);
            this.setBodyDir(dir);
        });
    }
    setBodyDir(dir) {
        document.body.dir = dir;
        document.dir = dir;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DocumentDirHandlerService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DocumentDirHandlerService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DocumentDirHandlerService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Injector }] });

const HTTP_ERROR_CONFIG = new InjectionToken('HTTP_ERROR_CONFIG');
/**
  @deprecated use **`CUSTOM_ERROR_HANDLERS`** injection token instead of this, see more info https://abp.io/docs/latest/framework/ui/angular/http-requests
*/
const HTTP_ERROR_HANDLER = new InjectionToken('HTTP_ERROR_HANDLER');
const CUSTOM_ERROR_HANDLERS = new InjectionToken('CUSTOM_ERROR_HANDLERS');

const DEFAULT_ERROR_MESSAGES = {
    defaultError: {
        title: 'An error has occurred!',
        details: 'Error detail not sent by server.',
    },
    defaultError401: {
        title: 'You are not authenticated!',
        details: 'You should be authenticated (sign in) in order to perform this operation.',
    },
    defaultError403: {
        title: 'You are not authorized!',
        details: 'You are not allowed to perform this operation.',
    },
    defaultError404: {
        title: 'Resource not found!',
        details: 'The resource requested could not found on the server.',
    },
    defaultError500: {
        title: 'Internal server error',
        details: 'Error detail not sent by server.',
    },
};
const DEFAULT_ERROR_LOCALIZATIONS = {
    defaultError: {
        title: 'AbpUi::DefaultErrorMessage',
        details: 'AbpUi::DefaultErrorMessageDetail',
    },
    defaultError401: {
        title: 'AbpUi::DefaultErrorMessage401',
        details: 'AbpUi::DefaultErrorMessage401Detail',
    },
    defaultError403: {
        title: 'AbpUi::DefaultErrorMessage403',
        details: 'AbpUi::DefaultErrorMessage403Detail',
    },
    defaultError404: {
        title: 'AbpUi::DefaultErrorMessage404',
        details: 'AbpUi::DefaultErrorMessage404Detail',
    },
    defaultError500: {
        title: 'AbpUi::500Message',
        details: 'AbpUi::DefaultErrorMessage',
    },
};
const CUSTOM_HTTP_ERROR_HANDLER_PRIORITY = Object.freeze({
    veryLow: -99,
    low: -9,
    normal: 0,
    high: 9,
    veryHigh: 99,
});
const HTTP_ERROR_STATUS = {
    '401': 'AbpUi::401Message',
    '403': 'AbpUi::403Message',
    '404': 'AbpUi::404Message',
    '500': 'AbpUi::500Message',
};
const HTTP_ERROR_DETAIL = {
    '401': 'AbpUi::DefaultErrorMessage401Detail',
    '403': 'AbpUi::DefaultErrorMessage403Detail',
    '404': 'AbpUi::DefaultErrorMessage404Detail',
    '500': 'AbpUi::DefaultErrorMessage',
};

var styles = `
.is-invalid .form-control {
  border-color: #dc3545;
  border-style: solid !important;
  padding-right: calc(1.5em + .75rem);
  background-image: url(data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e);
  background-repeat: no-repeat;
  background-position: right calc(.375em + .1875rem) center;
  background-size: calc(.75em + .375rem) calc(.75em + .375rem);
}

.is-invalid .invalid-feedback,
.is-invalid + * .invalid-feedback {
  display: block;
}

.data-tables-filter {
  text-align: right;
}

[dir=rtl] .data-tables-filter {
  text-align: left;
}

.pointer {
  cursor: pointer;
}

.navbar .dropdown-submenu a::after {
  transform: rotate(-90deg);
  position: absolute;
  right: 16px;
  top: 18px;
}

.navbar .dropdown-menu {
  min-width: 215px;
}

.datatable-scroll {
  margin-bottom: 5px !important;
  width: unset !important;
}

.ui-table-scrollable-body::-webkit-scrollbar {
  height: 5px !important;
  width: 5px !important;
}

.ui-table-scrollable-body::-webkit-scrollbar-track {
  background: #ddd;
}

.ui-table-scrollable-body::-webkit-scrollbar-thumb {
  background: #8a8686;
}

.abp-ellipsis-inline {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.abp-ellipsis {
  overflow: hidden !important;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.ui-widget-overlay {
  z-index: 1000;
}

.color-white {
  color: #FFF !important;
}

.custom-checkbox > label {
  cursor: pointer;
}

/* <animations */

.fade-in-top {
  animation: fadeInTop 0.2s ease-in-out;
}

.fade-out-top {
  animation: fadeOutTop 0.2s ease-in-out;
}

.abp-collapsed-height {
  -moz-transition: max-height linear 0.35s;
  -ms-transition: max-height linear 0.35s;
  -o-transition: max-height linear 0.35s;
  -webkit-transition: max-height linear 0.35s;
  overflow:hidden;
  transition:max-height 0.35s linear;
  height:auto;
  max-height: 0;
}

.abp-mh-25 {
  max-height: 25vh;
}

.abp-mh-50 {
  transition:max-height 0.65s linear;
  max-height: 50vh;
}

.abp-mh-75 {
  transition:max-height 0.85s linear;
  max-height: 75vh;
}

.abp-mh-100 {
  transition:max-height 1s linear;
  max-height: 100vh;
}

[class^="sorting"] {
  opacity: .3;
  cursor: pointer;
}
[class^="sorting"]:before {
  right: 0.5rem;
  content: "↑";
}
[class^="sorting"]:after {
  right: 0.5rem;
  content: "↓";
}

.sorting_desc {
  opacity: 1;
}
.sorting_desc:before {
  opacity: .3;
}

.sorting_asc {
  opacity: 1;
}
.sorting_asc:after {
  opacity: .3;
}
.ngx-datatable.material {
  box-shadow: none;
}
ngb-typeahead-window, ngb-typeahead-window.dropdown-menu {
  max-height: 25em;
  overflow-y: scroll !important;
  z-index: 1050;
}

.abp-modal-header {
  word-break: break-word;
}


@keyframes fadeInTop {
  from {
    transform: translateY(-5px);
    opacity: 0;
  }

  to {
    transform: translateY(0px);
    opacity: 1;
  }
}

@keyframes fadeOutTop {
  to {
    transform: translateY(-5px);
    opacity: 0;
  }
}

/* </animations */
.ngb-dp-body {
  z-index: 1055 !important;
}
`;

const THEME_SHARED_APPEND_CONTENT = new InjectionToken('THEME_SHARED_APPEND_CONTENT', {
    providedIn: 'root',
    factory: () => {
        const domInsertion = inject(DomInsertionService);
        domInsertion.insertContent(CONTENT_STRATEGY.AppendStyleToHead(styles));
    },
});

class NavItem {
    constructor(props) {
        Object.assign(this, props);
    }
}

class AbstractMenuService {
    get items() {
        return this._items$.value;
    }
    get items$() {
        return this._items$.asObservable();
    }
    constructor() {
        this._items$ = new BehaviorSubject([]);
        this.sortItems = (a, b) => {
            return this.sortFn(a, b);
        };
        this.sortFn = inject(SORT_COMPARE_FUNC);
    }
    addItems(newItems) {
        const items = [...this.items];
        newItems.forEach(item => {
            const index = items.findIndex(i => i.id === item.id);
            const data = new this.baseClass(item);
            if (index > -1) {
                items[index] = data;
                return;
            }
            items.push(data);
        });
        items.sort(this.sortItems);
        this._items$.next(items);
    }
    removeItem(id) {
        const index = this.items.findIndex(item => item.id === id);
        if (index < 0)
            return;
        const items = [...this.items.slice(0, index), ...this.items.slice(index + 1)];
        this._items$.next(items);
    }
    patchItem(id, item) {
        const index = this.items.findIndex(i => i.id === id);
        if (index < 0)
            return;
        const items = [...this.items];
        items[index] = new this.baseClass({ ...items[index], ...item });
        items.sort(this.sortItems);
        this._items$.next(items);
    }
}

class NavItemsService extends AbstractMenuService {
    constructor() {
        super(...arguments);
        this.baseClass = NavItem;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NavItemsService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NavItemsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: NavItemsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class PageAlertService {
    constructor() {
        this.alerts = new InternalStore([]);
        this.alerts$ = this.alerts.sliceState(state => state);
    }
    show(alert) {
        const newAlert = {
            ...alert,
            dismissible: alert.dismissible ?? true,
        };
        this.alerts.set([newAlert, ...this.alerts.state]);
    }
    remove(index) {
        const alerts = [...this.alerts.state];
        alerts.splice(index, 1);
        this.alerts.set(alerts);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PageAlertService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PageAlertService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PageAlertService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ToasterService {
    setContainer() {
        this.containerComponentRef = this.contentProjectionService.projectContent(PROJECTION_STRATEGY.AppendComponentToBody(ToastContainerComponent, {
            toasts$: this.toasts$,
            remove: this.remove,
        }));
        this.containerComponentRef.changeDetectorRef.detectChanges();
    }
    constructor() {
        this.toasts$ = new ReplaySubject(1);
        this.lastId = -1;
        this.toasts = [];
        /**
         * Removes the toast with given id.
         * @param id ID of the toast to be removed.
         */
        this.remove = (id) => {
            this.toasts = this.toasts.filter(toast => toast.options?.id !== id);
            this.toasts$.next(this.toasts);
        };
        this.contentProjectionService = inject(ContentProjectionService);
    }
    /**
     * Creates an info toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    info(message, title, options) {
        return this.show(message, title, 'info', options);
    }
    /**
     * Creates a success toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    success(message, title, options) {
        return this.show(message, title, 'success', options);
    }
    /**
     * Creates a warning toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    warn(message, title, options) {
        return this.show(message, title, 'warning', options);
    }
    /**
     * Creates an error toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param options Spesific style or structural options for individual toast
     */
    error(message, title, options) {
        return this.show(message, title, 'error', options);
    }
    /**
     * Creates a toast with given parameters.
     * @param message Content of the toast
     * @param title Title of the toast
     * @param severity Sets color of the toast. "success", "warning" etc.
     * @param options Spesific style or structural options for individual toast
     */
    show(message, title = undefined, severity = 'neutral', options = {}) {
        if (!this.containerComponentRef)
            this.setContainer();
        const id = ++this.lastId;
        this.toasts.push({
            message,
            title,
            severity,
            options: { closable: true, id, ...options },
        });
        this.toasts$.next(this.toasts);
        return id;
    }
    /**
     * Removes all open toasts at once.
     */
    clear(containerKey) {
        this.toasts = !containerKey
            ? []
            : this.toasts.filter(toast => toast.options?.containerKey !== containerKey);
        this.toasts$.next(this.toasts);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToasterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToasterService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ToasterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });

class UserMenu extends NavItem {
}

class UserMenuService extends AbstractMenuService {
    constructor() {
        super(...arguments);
        this.baseClass = UserMenu;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UserMenuService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UserMenuService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UserMenuService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class CreateErrorComponentService {
    constructor() {
        this.document = inject(DOCUMENT);
        this.rendererFactory = inject(RendererFactory2);
        this.routerEvents = inject(RouterEvents);
        this.injector = inject(Injector);
        this.envInjector = inject(EnvironmentInjector);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.componentRef = null;
        this.listenToRouterDataResolved();
    }
    listenToRouterDataResolved() {
        this.routerEvents
            .getEvents(ResolveEnd)
            .pipe(filter(() => !!this.componentRef))
            .subscribe(() => {
            this.componentRef?.destroy();
            this.componentRef = null;
        });
    }
    getErrorHostElement() {
        return this.document.body;
    }
    isCloseIconHidden() {
        return !!this.httpErrorConfig?.errorScreen?.hideCloseIcon;
    }
    canCreateCustomError(status) {
        const { component, forWhichErrors } = this.httpErrorConfig?.errorScreen || {};
        if (!component || !forWhichErrors) {
            return false;
        }
        return forWhichErrors.indexOf(status) > -1;
    }
    execute(instance) {
        const renderer = this.rendererFactory.createRenderer(null, null);
        const hostElement = this.getErrorHostElement();
        const host = renderer.selectRootElement(hostElement, true);
        this.componentRef = createComponent(HttpErrorWrapperComponent, {
            environmentInjector: this.envInjector,
        });
        for (const key in instance) {
            /* istanbul ignore else */
            if (Object.prototype.hasOwnProperty.call(this.componentRef.instance, key)) {
                this.componentRef.instance[key] = instance[key];
            }
        }
        this.componentRef.instance.hideCloseIcon = this.isCloseIconHidden();
        const appRef = this.injector.get(ApplicationRef);
        if (this.canCreateCustomError(instance.status)) {
            this.componentRef.instance.appRef = appRef;
            this.componentRef.instance.environmentInjector = this.envInjector;
            this.componentRef.instance.customComponent = this.httpErrorConfig.errorScreen?.component;
        }
        appRef.attachView(this.componentRef.hostView);
        renderer.appendChild(host, this.componentRef.hostView.rootNodes[0]);
        const destroy$ = new Subject();
        this.componentRef.instance.destroy$ = destroy$;
        destroy$.subscribe(() => {
            this.componentRef?.destroy();
            this.componentRef = null;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CreateErrorComponentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CreateErrorComponentService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CreateErrorComponentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [] });

function getErrorFromRequestBody(body) {
    let message;
    let title;
    if (body.details) {
        message = body.details;
        title = body.message;
    }
    else if (body.message) {
        title = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        message = body.message;
    }
    else {
        message = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        title = '';
    }
    return { message, title };
}

class AbpFormatErrorHandlerService {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.high;
        this.confirmationService = inject(ConfirmationService);
        this.authService = inject(AuthService);
        this.error = undefined;
    }
    navigateToLogin() {
        return this.authService.navigateToLogin();
    }
    canHandle(error) {
        if (error instanceof HttpErrorResponse && error.headers.get('_AbpErrorFormat')) {
            this.error = error;
            return true;
        }
        return false;
    }
    execute() {
        const { message, title } = getErrorFromRequestBody(this.error?.error?.error);
        this.confirmationService
            .error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        })
            .subscribe(() => {
            if (this.error?.status === 401) {
                this.navigateToLogin();
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpFormatErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpFormatErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpFormatErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class TenantResolveErrorHandlerService {
    constructor() {
        this.sessionService = inject(SessionStateService);
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.high;
        this.authService = inject(AuthService);
    }
    isTenantResolveError(error) {
        return error instanceof HttpErrorResponse && !!error.headers.get('Abp-Tenant-Resolve-Error');
    }
    canHandle(error) {
        return this.isTenantResolveError(error);
    }
    execute() {
        this.sessionService.setTenant(null);
        this.authService.logout().subscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TenantResolveErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TenantResolveErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: TenantResolveErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class StatusCodeErrorHandlerService {
    constructor() {
        this.confirmationService = inject(ConfirmationService);
        this.createErrorComponentService = inject(CreateErrorComponentService);
        this.authService = inject(AuthService);
        this.handledStatusCodes = [401, 403, 404, 500];
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.normal;
    }
    navigateToLogin() {
        this.authService.navigateToLogin();
    }
    showConfirmation(message, title) {
        return this.confirmationService.error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        });
    }
    showPage() {
        const key = `defaultError${this.status}`;
        const shouldRemoveDetail = [401, 404].indexOf(this.status) > -1;
        const instance = {
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS[key]?.title,
                defaultValue: DEFAULT_ERROR_MESSAGES[key]?.title,
            },
            details: {
                key: DEFAULT_ERROR_LOCALIZATIONS[key]?.details,
                defaultValue: DEFAULT_ERROR_MESSAGES[key]?.details,
            },
            status: this.status,
        };
        if (shouldRemoveDetail) {
            delete instance.details;
        }
        this.createErrorComponentService.execute(instance);
    }
    canHandle(error) {
        this.status = error?.status || 0;
        return this.handledStatusCodes.indexOf(this.status) > -1;
    }
    execute() {
        const key = `defaultError${this.status}`;
        const title = {
            key: DEFAULT_ERROR_LOCALIZATIONS[key]?.title,
            defaultValue: DEFAULT_ERROR_MESSAGES[key]?.title,
        };
        const message = {
            key: DEFAULT_ERROR_LOCALIZATIONS[key]?.details,
            defaultValue: DEFAULT_ERROR_MESSAGES[key]?.details,
        };
        const canCreateCustomError = this.createErrorComponentService.canCreateCustomError(this.status);
        switch (this.status) {
            case 401:
            case 404:
                if (canCreateCustomError) {
                    this.showPage();
                    break;
                }
                if (this.status === 401) {
                    this.authService.navigateToLogin();
                    break;
                }
                this.showConfirmation(title, message).subscribe();
                break;
            case 403:
            case 500:
                this.showPage();
                break;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: StatusCodeErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: StatusCodeErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: StatusCodeErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class UnknownStatusCodeErrorHandlerService {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.normal;
        this.statusText = 'Unknown Error';
        this.message = '';
        this.createErrorComponentService = inject(CreateErrorComponentService);
    }
    canHandle(error) {
        if (error && error.status === 0 && error.statusText === this.statusText) {
            this.message = error.message;
            return true;
        }
        return false;
    }
    execute() {
        this.createErrorComponentService.execute({
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
            },
            details: this.message,
            isHomeShow: false,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: UnknownStatusCodeErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class AbpAuthenticationErrorHandler {
    constructor() {
        this.priority = CUSTOM_HTTP_ERROR_HANDLER_PRIORITY.veryHigh;
        this.authService = inject(AuthService);
        this.configStateService = inject(ConfigStateService);
    }
    canHandle(error) {
        return error instanceof HttpErrorResponse && error.status === 401;
    }
    execute() {
        this.configStateService.refreshAppState().subscribe(({ currentUser }) => {
            if (!currentUser.isAuthenticated) {
                this.authService.logout({ noRedirectToLogoutUrl: true });
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpAuthenticationErrorHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpAuthenticationErrorHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbpAuthenticationErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class RouterErrorHandlerService {
    constructor() {
        this.routerEvents = inject(RouterEvents);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.createErrorComponentService = inject(CreateErrorComponentService);
        this.filterRouteErrors = (navigationError) => {
            if (!this.httpErrorConfig?.skipHandledErrorCodes) {
                return true;
            }
            return (navigationError.error?.message?.indexOf('Cannot match') > -1 &&
                this.httpErrorConfig.skipHandledErrorCodes.findIndex(code => code === 404) < 0);
        };
    }
    listen() {
        this.routerEvents
            .getNavigationEvents('Error')
            .pipe(filter(this.filterRouteErrors))
            .subscribe(() => this.show404Page());
    }
    show404Page() {
        const instance = {
            title: {
                key: DEFAULT_ERROR_LOCALIZATIONS.defaultError404.title,
                defaultValue: DEFAULT_ERROR_MESSAGES.defaultError404.title,
            },
            status: 404,
        };
        this.createErrorComponentService.execute(instance);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: RouterErrorHandlerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: RouterErrorHandlerService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: RouterErrorHandlerService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ErrorHandler {
    constructor(injector) {
        this.injector = injector;
        this.httpErrorReporter = inject(HttpErrorReporterService);
        this.confirmationService = inject(ConfirmationService);
        this.routerErrorHandlerService = inject(RouterErrorHandlerService);
        this.httpErrorConfig = inject(HTTP_ERROR_CONFIG);
        this.customErrorHandlers = inject(CUSTOM_ERROR_HANDLERS);
        this.httpErrorHandler = inject(HTTP_ERROR_HANDLER, { optional: true });
        this.executeErrorHandler = (error) => {
            if (this.httpErrorHandler) {
                return this.httpErrorHandler(this.injector, error);
            }
            return of(error);
        };
        this.filterRestErrors = ({ status }) => {
            if (typeof status !== 'number')
                return false;
            if (!this.httpErrorConfig?.skipHandledErrorCodes) {
                return true;
            }
            return this.httpErrorConfig.skipHandledErrorCodes?.findIndex(code => code === status) < 0;
        };
        this.listenToRestError();
        this.listenToRouterError();
    }
    listenToRouterError() {
        this.routerErrorHandlerService.listen();
    }
    listenToRestError() {
        this.httpErrorReporter.reporter$
            .pipe(filter(this.filterRestErrors), switchMap(this.executeErrorHandler))
            .subscribe(err => this.handleError(err));
    }
    sortHttpErrorHandlers(a, b) {
        return (b.priority || 0) - (a.priority || 0);
    }
    handleError(err) {
        if (this.customErrorHandlers && this.customErrorHandlers.length) {
            const errorHandlerService = this.customErrorHandlers
                .sort(this.sortHttpErrorHandlers)
                .find(service => service.canHandle(err));
            if (errorHandlerService) {
                errorHandlerService.execute();
                return;
            }
        }
        this.showError().subscribe();
    }
    showError() {
        const title = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.title,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.title,
        };
        const message = {
            key: DEFAULT_ERROR_LOCALIZATIONS.defaultError.details,
            defaultValue: DEFAULT_ERROR_MESSAGES.defaultError.details,
        };
        return this.confirmationService.error(message, title, {
            hideCancelBtn: true,
            yesText: 'AbpAccount::Close',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ErrorHandler, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ErrorHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i0.Injector }] });

const NG_BOOTSTRAP_CONFIG_PROVIDERS = [
    provideAppInitializer(() => {
        configureNgBootstrap();
    }),
];
function configureNgBootstrap() {
    const datepicker = inject(NgbInputDatepickerConfig);
    const typeahead = inject(NgbTypeaheadConfig);
    datepicker.container = 'body';
    typeahead.container = 'body';
}

const THEME_SHARED_ROUTE_PROVIDERS = [
    provideAppInitializer(() => {
        configureRoutes();
    }),
];
function configureRoutes() {
    const routesService = inject(RoutesService);
    routesService.add([
        {
            path: undefined,
            name: "AbpUiNavigation::Menu:Administration" /* eThemeSharedRouteNames.Administration */,
            iconClass: 'fa fa-wrench',
            order: 100,
        },
    ]);
}

const tenantNotFoundProvider = {
    provide: TENANT_NOT_FOUND_BY_NAME,
    useFactory: function () {
        const confirm = inject(ConfirmationService);
        return (response) => {
            const { error } = response.error;
            // hide loading donut
            const appRoot = document.querySelector('app-root div.donut');
            if (appRoot) {
                appRoot.remove();
            }
            confirm.error(error.details, error.message, { hideCancelBtn: true, hideYesBtn: true });
        };
    },
};

const DEFAULT_HANDLERS_PROVIDERS = [
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: TenantResolveErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: AbpFormatErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: StatusCodeErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: UnknownStatusCodeErrorHandlerService,
    },
    {
        provide: CUSTOM_ERROR_HANDLERS,
        multi: true,
        useExisting: AbpAuthenticationErrorHandler,
    },
];

const DEFAULT_VALIDATION_BLUEPRINTS = {
    creditCard: 'AbpValidation::ThisFieldIsNotAValidCreditCardNumber.',
    email: 'AbpValidation::ThisFieldIsNotAValidEmailAddress.',
    invalid: 'AbpValidation::ThisFieldIsNotValid.',
    max: 'AbpValidation::ThisFieldMustBeLessOrEqual{0}[{{ max }}]',
    maxlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMaximumLengthOf{0}[{{ requiredLength }}]',
    min: 'AbpValidation::ThisFieldMustBeGreaterThanOrEqual{0}[{{ min }}]',
    minlength: 'AbpValidation::ThisFieldMustBeAStringOrArrayTypeWithAMinimumLengthOf{0}[{{ requiredLength }}]',
    ngbDate: 'AbpValidation::ThisFieldIsNotValid.',
    passwordMismatch: 'AbpIdentity::Volo.Abp.Identity:PasswordConfirmationFailed',
    range: 'AbpValidation::ThisFieldMustBeBetween{0}And{1}[{{ min }},{{ max }}]',
    required: 'AbpValidation::ThisFieldIsRequired.',
    url: 'AbpValidation::ThisFieldIsNotAValidFullyQualifiedHttpHttpsOrFtpUrl',
    passwordRequiresLower: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresLower',
    passwordRequiresUpper: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresUpper',
    passwordRequiresDigit: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresDigit',
    passwordRequiresNonAlphanumeric: 'AbpIdentity::Volo.Abp.Identity:PasswordRequiresNonAlphanumeric',
    usernamePattern: 'AbpIdentity::Volo.Abp.Identity:InvalidUserName[{{ actualValue }}]',
    customMessage: '{{ customMessage }}'
};

var scripts = '';

function isNumber(value) {
    return !isNaN(toInteger(value));
}
function toInteger(value) {
    return parseInt(`${value}`, 10);
}
class DateParserFormatter extends NgbDateParserFormatter {
    constructor(configState, locale) {
        super();
        this.configState = configState;
        this.locale = locale;
    }
    parse(value) {
        if (value) {
            const dateParts = value.trim().split('-');
            // TODO: CHANGED
            if (dateParts.length === 1 && isNumber(dateParts[0])) {
                return { year: toInteger(dateParts[0]), month: -1, day: -1 };
            }
            else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {
                return { year: toInteger(dateParts[0]), month: toInteger(dateParts[1]), day: -1 };
            }
            else if (dateParts.length === 3 &&
                isNumber(dateParts[0]) &&
                isNumber(dateParts[1]) &&
                isNumber(dateParts[2])) {
                return {
                    year: toInteger(dateParts[0]),
                    month: toInteger(dateParts[1]),
                    day: toInteger(dateParts[2]),
                };
            }
        }
        return null;
    }
    format(date) {
        if (!date)
            return '';
        const localization = this.configState.getOne('localization');
        const dateFormat = localization.currentCulture?.dateTimeFormat?.shortDatePattern || 'yyyy-MM-dd';
        return formatDate(new Date(date.year, date.month - 1, date.day), dateFormat, this.locale);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateParserFormatter, deps: [{ token: i2.ConfigStateService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateParserFormatter }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: DateParserFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i2.ConfigStateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }] });

const { minLength, maxLength } = Validators;
function getPasswordValidators(injector) {
    const getRule = getRuleFn(injector);
    const passwordRulesArr = [];
    let requiredLength = 1;
    if (getRule('RequireDigit') === 'true') {
        passwordRulesArr.push('number');
    }
    if (getRule('RequireLowercase') === 'true') {
        passwordRulesArr.push('small');
    }
    if (getRule('RequireUppercase') === 'true') {
        passwordRulesArr.push('capital');
    }
    if (getRule('RequireNonAlphanumeric') === 'true') {
        passwordRulesArr.push('special');
    }
    if (Number.isInteger(+getRule('RequiredLength'))) {
        requiredLength = +getRule('RequiredLength');
    }
    const passwordValidators = passwordRulesArr.map(rule => validatePassword(rule));
    return [...passwordValidators, minLength(requiredLength), maxLength(128)];
}
function getRuleFn(injector) {
    const configState = injector.get(ConfigStateService);
    return (key) => {
        const passwordRules = configState.getSettings('Identity.Password');
        return (passwordRules[`Abp.Identity.Password.${key}`] || '').toLowerCase();
    };
}
const errorMessageMap = {
    small: 'passwordRequiresLower',
    capital: 'passwordRequiresUpper',
    number: 'passwordRequiresDigit',
    special: 'passwordRequiresNonAlphanumeric',
};
function validatePassword(shouldContain) {
    return (control) => {
        if (!control.value)
            return null;
        const value = normalizeDiacritics(control.value);
        const regexMap = {
            small: /.*[a-z].*/,
            capital: /.*[A-Z].*/,
            number: /.*[0-9].*/,
            special: /.*[^0-9a-zA-Z].*/,
        };
        const regex = regexMap[shouldContain];
        const isValid = regex.test(value);
        if (isValid) {
            return null;
        }
        const error = errorMessageMap[shouldContain];
        return {
            [error]: true,
        };
    };
}

var ThemeSharedFeatureKind;
(function (ThemeSharedFeatureKind) {
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["HttpErrorConfig"] = 0] = "HttpErrorConfig";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidationBluePrint"] = 1] = "ValidationBluePrint";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidationErrorsFn"] = 2] = "ValidationErrorsFn";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ValidateOnSubmit"] = 3] = "ValidateOnSubmit";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["Validation"] = 4] = "Validation";
    ThemeSharedFeatureKind[ThemeSharedFeatureKind["ConfirmationIcons"] = 5] = "ConfirmationIcons";
})(ThemeSharedFeatureKind || (ThemeSharedFeatureKind = {}));
function makeThemeSharedFeature(kind, providers) {
    return {
        ɵkind: kind,
        ɵproviders: providers,
    };
}
function withHttpErrorConfig(httpErrorConfig) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.HttpErrorConfig, [
        {
            provide: HTTP_ERROR_CONFIG,
            useValue: httpErrorConfig,
        },
    ]);
}
function withValidationBluePrint(bluePrints) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidationBluePrint, [
        {
            provide: VALIDATION_BLUEPRINTS,
            useValue: {
                ...DEFAULT_VALIDATION_BLUEPRINTS,
                ...(bluePrints || {}),
            },
        },
    ]);
}
function withValidationMapErrorsFn(mapErrorsFn) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidationErrorsFn, [
        {
            provide: VALIDATION_MAP_ERRORS_FN,
            useValue: mapErrorsFn || defaultMapErrorsFn,
        },
    ]);
}
function withValidateOnSubmit(validateOnSubmit) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.ValidateOnSubmit, [
        {
            provide: VALIDATION_VALIDATE_ON_SUBMIT,
            useValue: validateOnSubmit,
        },
    ]);
}
function withConfirmationIcon(confirmationIcons) {
    return makeThemeSharedFeature(ThemeSharedFeatureKind.HttpErrorConfig, [
        {
            provide: CONFIRMATION_ICONS,
            useValue: { ...DEFAULT_CONFIRMATION_ICONS, ...(confirmationIcons || {}) },
        },
    ]);
}
function provideAbpThemeShared(...features) {
    const providers = [
        provideAppInitializer(() => {
            inject(ErrorHandler);
            inject(THEME_SHARED_APPEND_CONTENT);
            inject(DocumentDirHandlerService);
        }),
        THEME_SHARED_ROUTE_PROVIDERS,
        { provide: HTTP_ERROR_CONFIG, useValue: undefined },
        { provide: NgbDateParserFormatter, useClass: DateParserFormatter },
        NG_BOOTSTRAP_CONFIG_PROVIDERS,
        {
            provide: VALIDATION_BLUEPRINTS,
            useValue: { ...DEFAULT_VALIDATION_BLUEPRINTS },
        },
        {
            provide: VALIDATION_MAP_ERRORS_FN,
            useValue: defaultMapErrorsFn,
        },
        {
            provide: VALIDATION_VALIDATE_ON_SUBMIT,
            useValue: undefined,
        },
        DocumentDirHandlerService,
        {
            provide: CONFIRMATION_ICONS,
            useValue: { ...DEFAULT_CONFIRMATION_ICONS },
        },
        tenantNotFoundProvider,
        DEFAULT_HANDLERS_PROVIDERS,
    ];
    for (const feature of features) {
        providers.push(...feature.ɵproviders);
    }
    return makeEnvironmentProviders(providers);
}

const declarationsWithExports = [
    BreadcrumbComponent,
    BreadcrumbItemsComponent,
    ButtonComponent,
    ConfirmationComponent,
    LoaderBarComponent,
    LoadingComponent,
    ModalComponent,
    ToastComponent,
    ToastContainerComponent,
    LoadingDirective,
    ModalCloseDirective,
    FormInputComponent,
    FormCheckboxComponent,
];
class BaseThemeSharedModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BaseThemeSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: BaseThemeSharedModule, declarations: [BreadcrumbComponent,
            BreadcrumbItemsComponent,
            ButtonComponent,
            ConfirmationComponent,
            LoaderBarComponent,
            LoadingComponent,
            ModalComponent,
            ToastComponent,
            ToastContainerComponent,
            LoadingDirective,
            ModalCloseDirective,
            FormInputComponent,
            FormCheckboxComponent, HttpErrorWrapperComponent], imports: [CoreModule,
            NgxDatatableModule,
            NgxValidateCoreModule,
            NgbPaginationModule,
            EllipsisDirective,
            CardModule,
            PasswordComponent,
            NgxDatatableDefaultDirective,
            NgxDatatableListDirective,
            DisabledDirective,
            AbpVisibleDirective], exports: [NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule,
            DisabledDirective,
            AbpVisibleDirective,
            NgxDatatableListDirective,
            NgxDatatableDefaultDirective,
            PasswordComponent, BreadcrumbComponent,
            BreadcrumbItemsComponent,
            ButtonComponent,
            ConfirmationComponent,
            LoaderBarComponent,
            LoadingComponent,
            ModalComponent,
            ToastComponent,
            ToastContainerComponent,
            LoadingDirective,
            ModalCloseDirective,
            FormInputComponent,
            FormCheckboxComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BaseThemeSharedModule, providers: [DatePipe], imports: [CoreModule,
            NgxDatatableModule,
            NgxValidateCoreModule,
            NgbPaginationModule,
            CardModule,
            PasswordComponent, NgxDatatableModule,
            NgxValidateCoreModule,
            CardModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: BaseThemeSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CoreModule,
                        NgxDatatableModule,
                        NgxValidateCoreModule,
                        NgbPaginationModule,
                        EllipsisDirective,
                        CardModule,
                        PasswordComponent,
                        NgxDatatableDefaultDirective,
                        NgxDatatableListDirective,
                        DisabledDirective,
                        AbpVisibleDirective,
                    ],
                    declarations: [...declarationsWithExports, HttpErrorWrapperComponent],
                    exports: [
                        NgxDatatableModule,
                        NgxValidateCoreModule,
                        CardModule,
                        DisabledDirective,
                        AbpVisibleDirective,
                        NgxDatatableListDirective,
                        NgxDatatableDefaultDirective,
                        PasswordComponent,
                        ...declarationsWithExports,
                    ],
                    providers: [DatePipe],
                }]
        }] });
class ThemeSharedModule {
    /**
     * @deprecated forRoot method is deprecated, use `provideAbpThemeShared` *function* for config settings.
     */
    static forRoot({ httpErrorConfig, validation = {}, confirmationIcons = {} } = {}) {
        return {
            ngModule: ThemeSharedModule,
            providers: [
                provideAbpThemeShared(withHttpErrorConfig(httpErrorConfig), withValidationBluePrint(validation.blueprints), withValidationMapErrorsFn(validation.mapErrorsFn), withValidateOnSubmit(validation.validateOnSubmit), withConfirmationIcon(confirmationIcons)),
            ],
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: ThemeSharedModule, imports: [BaseThemeSharedModule], exports: [BaseThemeSharedModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeSharedModule, imports: [BaseThemeSharedModule, BaseThemeSharedModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ThemeSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BaseThemeSharedModule],
                    exports: [BaseThemeSharedModule],
                }]
        }] });

/*
 * Public API Surface of theme-shared
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbpAuthenticationErrorHandler, AbpFormatErrorHandlerService, AbpVisibleDirective, BaseThemeSharedModule, BreadcrumbComponent, BreadcrumbItemsComponent, ButtonComponent, CONFIRMATION_ICONS, CUSTOM_ERROR_HANDLERS, CUSTOM_HTTP_ERROR_HANDLER_PRIORITY, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardHeaderDirective, CardImgTopDirective, CardModule, CardSubtitleDirective, CardTitleDirective, Confirmation, ConfirmationComponent, ConfirmationService, CreateErrorComponentService, DEFAULT_CONFIRMATION_ICONS, DEFAULT_ERROR_LOCALIZATIONS, DEFAULT_ERROR_MESSAGES, DEFAULT_HANDLERS_PROVIDERS, DEFAULT_VALIDATION_BLUEPRINTS, DateAdapter, DateParserFormatter, DateTimeAdapter, DisabledDirective, DocumentDirHandlerService, EllipsisDirective, ErrorHandler, FormCheckboxComponent, FormInputComponent, HTTP_ERROR_CONFIG, HTTP_ERROR_DETAIL, HTTP_ERROR_HANDLER, HTTP_ERROR_STATUS, HttpErrorWrapperComponent, InternetConnectionStatusComponent, LoaderBarComponent, LoadingComponent, LoadingDirective, ModalCloseDirective, ModalComponent, ModalRefService, NGX_DATATABLE_MESSAGES, NG_BOOTSTRAP_CONFIG_PROVIDERS, NavItem, NavItemsService, NgxDatatableDefaultDirective, NgxDatatableListDirective, PageAlertService, PasswordComponent, RouterErrorHandlerService, SUPPRESS_UNSAVED_CHANGES_WARNING, SpinnerComponent, StatusCodeErrorHandlerService, THEME_SHARED_APPEND_CONTENT, THEME_SHARED_ROUTE_PROVIDERS, TenantResolveErrorHandlerService, ThemeSharedFeatureKind, ThemeSharedModule, TimeAdapter, ToastComponent, ToastContainerComponent, ToasterService, UnknownStatusCodeErrorHandlerService, UserMenu, UserMenuService, bounceIn, collapse, collapseLinearWithMargin, collapseWithMargin, collapseX, collapseY, collapseYWithMargin, configureNgBootstrap, configureRoutes, defaultNgxDatatableMessages, dialogAnimation, eFormComponets, expandX, expandY, expandYWithMargin, fadeAnimation, fadeIn, fadeInDown, fadeInLeft, fadeInRight, fadeInUp, fadeOut, fadeOutDown, fadeOutLeft, fadeOutRight, fadeOutUp, getErrorFromRequestBody, getPasswordValidators, provideAbpThemeShared, slideFromBottom, tenantNotFoundProvider, toastInOut, validatePassword, withConfirmationIcon, withHttpErrorConfig, withValidateOnSubmit, withValidationBluePrint, withValidationMapErrorsFn };
//# sourceMappingURL=abp-ng.theme.shared.mjs.map
