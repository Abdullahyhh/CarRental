"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.styleCompareFn = exports.removeThemeBasedStyles = exports.getProjectTargetOptions = exports.getImportPaths = exports.createSourceFile = exports.insertProviders = exports.insertImports = exports.removeProviderFromNgModuleMetadata = exports.removeImportFromNgModuleMetadata = exports.removeImportPath = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const ts = require("typescript");
const style_map_1 = require("./style-map");
const utils_1 = require("../../utils");
const ast_utils_1 = require("../../utils/angular/ast-utils");
function default_1(_options) {
    return async () => {
        const targetThemeName = _options.name;
        const selectedProject = _options.targetProject;
        if (!targetThemeName) {
            throw new schematics_1.SchematicsException('The theme name does not selected');
        }
        return (0, schematics_1.chain)([
            (0, utils_1.updateWorkspace)(storedWorkspace => {
                updateProjectStyle(selectedProject, storedWorkspace, targetThemeName);
            }),
            updateAppModule(selectedProject, targetThemeName),
        ]);
    };
}
exports.default = default_1;
function updateProjectStyle(projectName, workspace, targetThemeName) {
    const project = workspace.projects.get(projectName);
    if (!project) {
        throw new schematics_1.SchematicsException('The target project does not selected');
    }
    if ((0, utils_1.isLibrary)(project)) {
        throw new schematics_1.SchematicsException('The library project does not supported');
    }
    const targetOption = getProjectTargetOptions(project, 'build');
    const styles = targetOption.styles;
    const sanitizedStyles = removeThemeBasedStyles(styles);
    const newStyles = style_map_1.styleMap.get(targetThemeName);
    if (!newStyles) {
        throw new schematics_1.SchematicsException('The theme does not found');
    }
    targetOption.styles = [...newStyles, ...sanitizedStyles];
}
function updateAppModule(selectedProject, targetThemeName) {
    return async (host) => {
        const appModulePath = (await (0, utils_1.createDefaultPath)(host, selectedProject)) + '/app.module.ts';
        return (0, schematics_1.chain)([
            removeImportPath(appModulePath, targetThemeName),
            removeImportFromNgModuleMetadata(appModulePath, targetThemeName),
            removeProviderFromNgModuleMetadata(appModulePath, targetThemeName),
            insertImports(appModulePath, targetThemeName),
            insertProviders(appModulePath, targetThemeName),
        ]);
    };
}
function removeImportPath(appModulePath, selectedTheme) {
    return (host) => {
        const recorder = host.beginUpdate(appModulePath);
        const source = createSourceFile(host, appModulePath);
        const impMap = getImportPaths(selectedTheme, true);
        const nodes = (0, ast_utils_1.findNodes)(source, ts.isImportDeclaration);
        const filteredNodes = nodes.filter(node => impMap.some(({ path, importName }) => {
            const sourceModule = node.getFullText();
            const moduleName = importName.split('.')[0];
            if (path && sourceModule.match(path)) {
                return true;
            }
            return !!(moduleName && sourceModule.match(moduleName));
        }));
        if (filteredNodes?.length < 1) {
            return;
        }
        filteredNodes.map(importPath => recorder.remove(importPath.getStart(), importPath.getWidth() + 1));
        host.commitUpdate(recorder);
        return host;
    };
}
exports.removeImportPath = removeImportPath;
function removeImportFromNgModuleMetadata(appModulePath, selectedTheme) {
    return (host) => {
        const recorder = host.beginUpdate(appModulePath);
        const source = createSourceFile(host, appModulePath);
        const impMap = getImportPaths(selectedTheme, true);
        const node = (0, ast_utils_1.getDecoratorMetadata)(source, 'NgModule', '@angular/core')[0] || {};
        if (!node) {
            throw new schematics_1.SchematicsException('The app module does not found');
        }
        const matchingProperties = (0, ast_utils_1.getMetadataField)(node, 'imports');
        const assignment = matchingProperties[0];
        const assignmentInit = assignment.initializer;
        const elements = assignmentInit.elements;
        if (!elements || elements.length < 1) {
            throw new schematics_1.SchematicsException(`Elements could not found: ${elements}`);
        }
        const filteredElements = elements.filter(f => impMap.some(s => f.getText().match(s.importName)));
        if (!filteredElements || filteredElements.length < 1) {
            return;
        }
        filteredElements.map(willRemoveModule => recorder.remove(willRemoveModule.getStart(), willRemoveModule.getWidth() + 1));
        host.commitUpdate(recorder);
        return host;
    };
}
exports.removeImportFromNgModuleMetadata = removeImportFromNgModuleMetadata;
function removeProviderFromNgModuleMetadata(appModulePath, selectedTheme) {
    return (host) => {
        const recorder = host.beginUpdate(appModulePath);
        const source = createSourceFile(host, appModulePath);
        const impMap = getImportPaths(selectedTheme, true);
        const node = (0, ast_utils_1.getDecoratorMetadata)(source, 'NgModule', '@angular/core')[0] || {};
        if (!node) {
            throw new schematics_1.SchematicsException('The app module does not found');
        }
        const matchingProperties = (0, ast_utils_1.getMetadataField)(node, 'providers');
        const assignment = matchingProperties[0];
        const assignmentInit = assignment.initializer;
        const elements = assignmentInit.elements;
        if (!elements || elements.length < 1) {
            throw new schematics_1.SchematicsException(`Elements could not found: ${elements}`);
        }
        const filteredElements = elements.filter(f => impMap.filter(f => !!f.provider).some(s => f.getText().match(s.provider)));
        if (!filteredElements || filteredElements.length < 1) {
            return;
        }
        filteredElements.map(willRemoveModule => {
            recorder.remove(willRemoveModule.getStart(), willRemoveModule.getWidth());
        });
        host.commitUpdate(recorder);
        return host;
    };
}
exports.removeProviderFromNgModuleMetadata = removeProviderFromNgModuleMetadata;
function insertImports(appModulePath, selectedTheme) {
    return (host) => {
        const recorder = host.beginUpdate(appModulePath);
        const source = createSourceFile(host, appModulePath);
        const selected = style_map_1.importMap.get(selectedTheme);
        if (!selected) {
            return host;
        }
        const changes = [];
        selected.map(({ importName, path }) => changes.push(...(0, ast_utils_1.addImportToModule)(source, appModulePath, importName, path)));
        if (changes.length > 0) {
            for (const change of changes) {
                if (change instanceof utils_1.InsertChange) {
                    recorder.insertLeft(change.order, change.toAdd);
                }
            }
        }
        host.commitUpdate(recorder);
        return host;
    };
}
exports.insertImports = insertImports;
function insertProviders(appModulePath, selectedTheme) {
    return (host) => {
        const recorder = host.beginUpdate(appModulePath);
        const source = createSourceFile(host, appModulePath);
        const selected = style_map_1.importMap.get(selectedTheme);
        if (!selected) {
            return host;
        }
        const changes = [];
        selected.map(({ path, provider }) => {
            if (provider) {
                changes.push(...(0, ast_utils_1.addProviderToModule)(source, appModulePath, provider + '()', path));
            }
        });
        for (const change of changes) {
            if (change instanceof utils_1.InsertChange) {
                recorder.insertLeft(change.order, change.toAdd);
            }
        }
        host.commitUpdate(recorder);
        return host;
    };
}
exports.insertProviders = insertProviders;
function createSourceFile(host, appModulePath) {
    const buffer = host.read(appModulePath);
    if (!buffer || buffer.length === 0) {
        throw new schematics_1.SchematicsException(`${appModulePath} file could not be read.`);
    }
    const sourceText = buffer.toString('utf-8');
    return ts.createSourceFile(appModulePath, sourceText, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
}
exports.createSourceFile = createSourceFile;
/**
 * Returns all import paths except the selected theme
 * @param selectedTheme The selected theme
 * @param getAll If true, returns all import paths
 */
function getImportPaths(selectedTheme, getAll = false) {
    if (getAll) {
        return Array.from(style_map_1.importMap.values()).reduce((acc, val) => [...acc, ...val], []);
    }
    return Array.from(style_map_1.importMap.values())
        .filter(f => f !== style_map_1.importMap.get(selectedTheme))
        .reduce((acc, val) => [...acc, ...val], []);
}
exports.getImportPaths = getImportPaths;
function getProjectTargetOptions(project, buildTarget) {
    const options = project.targets?.get(buildTarget)?.options;
    if (!options) {
        throw new schematics_1.SchematicsException(`Cannot determine project target configuration for: ${buildTarget}.`);
    }
    return options;
}
exports.getProjectTargetOptions = getProjectTargetOptions;
function removeThemeBasedStyles(styles) {
    return styles.filter(s => !style_map_1.allStyles.some(x => (0, exports.styleCompareFn)(s, x)));
}
exports.removeThemeBasedStyles = removeThemeBasedStyles;
const styleCompareFn = (item1, item2) => {
    const type1 = typeof item1;
    const type2 = typeof item1;
    if (type1 !== type2) {
        return false;
    }
    if (type1 === 'string') {
        return item1 === item2;
    }
    const o1 = item1;
    const o2 = item2;
    return o1.bundleName && o2.bundleName && o1.bundleName == o2.bundleName;
};
exports.styleCompareFn = styleCompareFn;
//# sourceMappingURL=index.js.map