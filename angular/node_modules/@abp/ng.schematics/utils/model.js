"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSelfGenericProps = exports.resolveAbpPackages = exports.parseBaseTypeWithGenericTypes = exports.createRefToImportReducerCreator = exports.createImportRefToInterfaceReducerCreator = exports.createImportRefsToModelReducer = void 0;
const models_1 = require("../models");
const generics_1 = require("./generics");
const namespace_1 = require("./namespace");
const path_1 = require("./path");
const text_1 = require("./text");
const tree_1 = require("./tree");
const type_1 = require("./type");
const constants_1 = require("../constants");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const shouldQuote = require('should-quote');
function createImportRefsToModelReducer(params) {
    const reduceImportRefsToInterfaces = createImportRefToInterfaceReducerCreator(params);
    const createRefToImportReducer = createRefToImportReducerCreator(params);
    const { solution, types } = params;
    return (models, importRefs) => {
        const enums = [];
        const interfaces = importRefs.reduce(reduceImportRefsToInterfaces, []);
        sortInterfaces(interfaces);
        interfaces.forEach(_interface => {
            if (constants_1.VOLO_REGEX.test(_interface.ref) || constants_1.VOLO_PACKAGE_PROXY_IMPORTS.has(_interface.ref))
                return;
            if (types[_interface.ref].isEnum) {
                if (!enums.includes(_interface.ref))
                    enums.push(_interface.ref);
                return;
            }
            const index = models.findIndex(m => m.namespace === _interface.namespace);
            if (index > -1) {
                if (models[index].interfaces.some(i => i.identifier === _interface.identifier))
                    return;
                models[index].interfaces.push(_interface);
            }
            else {
                const { namespace } = _interface;
                models.push(new models_1.Model({
                    interfaces: [_interface],
                    namespace,
                    path: (0, path_1.relativePathToModel)(namespace, namespace),
                }));
            }
        });
        models.forEach(model => {
            const toBeImported = [];
            model.interfaces.forEach(_interface => {
                const { baseType } = types[_interface.ref];
                if (baseType && (0, namespace_1.parseNamespace)(solution, baseType) !== model.namespace) {
                    const baseTypeWithGenericParams = parseBaseTypeWithGenericTypes(baseType);
                    baseTypeWithGenericParams.forEach(t => {
                        toBeImported.push({
                            type: t,
                            isEnum: false,
                        });
                    });
                }
                [..._interface.properties, ..._interface.generics].forEach(prop => {
                    prop.refs.forEach(ref => {
                        const propType = types[ref];
                        if (!propType) {
                            return;
                        }
                        if (propType.isEnum) {
                            toBeImported.push({ type: ref, isEnum: true });
                        }
                        else if ((0, namespace_1.parseNamespace)(solution, ref) !== model.namespace) {
                            toBeImported.push({ type: ref, isEnum: false });
                        }
                    });
                });
            });
            if (!toBeImported.length)
                return;
            const reduceRefToImport = createRefToImportReducer(model.namespace);
            reduceRefToImport(model.imports, toBeImported);
        });
        return models;
    };
}
exports.createImportRefsToModelReducer = createImportRefsToModelReducer;
function sortInterfaces(interfaces) {
    interfaces.sort((a, b) => (a.identifier > b.identifier ? 1 : -1));
}
function createImportRefToInterfaceReducerCreator(params) {
    const { solution, types } = params;
    const parseType = (0, type_1.createTypeParser)(type_1.removeTypeModifiers);
    const simplifyType = (0, type_1.createTypeSimplifier)();
    const getIdentifier = (type) => (0, type_1.removeTypeModifiers)(simplifyType(type));
    const genericsCollector = new generics_1.GenericsCollector(getIdentifier);
    return reduceRefsToInterfaces;
    function reduceRefsToInterfaces(interfaces, ref) {
        const typeDef = types[ref];
        if (!typeDef)
            return interfaces;
        const namespace = (0, namespace_1.parseNamespace)(solution, ref);
        let { baseType: base, genericArguments } = typeDef;
        genericArguments = genericArguments || [];
        let identifier = getIdentifier(ref);
        identifier = (0, generics_1.replacePlaceholdersWithGenerics)(identifier, genericArguments, genericsCollector);
        if (base) {
            if ((0, type_1.extendsSelf)(ref, base)) {
                genericsCollector.collect((0, generics_1.extractGenerics)(base).generics, genericArguments);
                return reduceRefsToInterfaces(interfaces, (0, generics_1.generateRefWithPlaceholders)(base));
            }
            else {
                base = getIdentifier(base);
            }
        }
        const { generics } = genericsCollector;
        const _interface = new models_1.Interface({ identifier, base, namespace, ref, generics });
        genericsCollector.reset();
        typeDef.properties?.forEach(prop => {
            let name = prop.jsonName || (0, text_1.camel)(prop.name);
            name = shouldQuote(name) ? `'${name}'` : name;
            let type = simplifyType(prop.typeSimple);
            if (prop.typeSimple.includes('enum')) {
                type = simplifyType(prop.type);
            }
            const refs = parseType(prop.type).reduce((acc, r) => acc.concat((0, tree_1.parseGenerics)(r).toGenerics()), []);
            const property = new models_1.Property({ name, type, refs });
            property.setOptional(isOptionalProperty(prop));
            _interface.properties.push(property);
        });
        interfaces.push(_interface);
        return [..._interface.properties, ..._interface.generics]
            .reduce((refs, prop) => {
            prop.refs.forEach(type => {
                if (types[type]?.isEnum)
                    return;
                if (interfaces.some(i => i.ref === type))
                    return;
                refs.push(type);
            });
            return refs;
        }, [])
            .concat(base ? (0, tree_1.parseGenerics)(typeDef.baseType).toGenerics() : [])
            .reduce(reduceRefsToInterfaces, interfaces);
    }
}
exports.createImportRefToInterfaceReducerCreator = createImportRefToInterfaceReducerCreator;
function createRefToImportReducerCreator(params) {
    const { solution } = params;
    return (namespace) => (0, type_1.createTypesToImportsReducer)(solution, namespace);
}
exports.createRefToImportReducerCreator = createRefToImportReducerCreator;
function isOptionalProperty(prop) {
    return (prop.typeSimple.endsWith('?') ||
        ((prop.typeSimple === 'string' || prop.typeSimple.includes('enum')) && !prop.isRequired));
}
function parseBaseTypeWithGenericTypes(type) {
    const parsedTypeNode = (0, tree_1.parseGenerics)(type);
    const nodeToText = (node, acc = []) => {
        acc.push(node.data);
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                nodeToText(child, acc);
            });
        }
        return acc;
    };
    return nodeToText(parsedTypeNode);
}
exports.parseBaseTypeWithGenericTypes = parseBaseTypeWithGenericTypes;
function resolveAbpPackages(models) {
    for (const model of models) {
        renamePropForTenant(model.interfaces);
        model.imports.forEach((imp, i) => {
            for (const ref of imp.refs) {
                const path = constants_1.VOLO_PACKAGE_PROXY_IMPORTS.get(ref);
                if (path) {
                    model.imports[i] = new models_1.Import({ ...imp, path });
                }
            }
        });
    }
}
exports.resolveAbpPackages = resolveAbpPackages;
function renamePropForTenant(interfaces) {
    for (const inters of interfaces) {
        for (const prop of inters.properties) {
            const isTenant = prop.name.toLocaleLowerCase().includes(constants_1.TENANT_KEY);
            const isSaasDto = prop.refs.filter(f => f.startsWith(constants_1.SAAS_NAMESPACE)).length > 0;
            if (isTenant && isSaasDto) {
                prop.type = 'Saas' + prop.type;
            }
        }
    }
}
function resolveSelfGenericProps(params) {
    const { types, solution } = params;
    if (!types || !solution) {
        return;
    }
    Object.keys(types)
        .filter(f => f.startsWith(solution))
        .forEach(key => {
        const type = types[key];
        if (type.genericArguments?.length) {
            type.properties?.map(prop => {
                if (prop.type.includes('<>')) {
                    prop.type = prop.type.replace('<>', `<${type.genericArguments.join(', ')}>`);
                    prop.typeSimple = prop.typeSimple.replace('<>', `<${type.genericArguments.join(', ')}>`);
                }
            });
        }
    });
}
exports.resolveSelfGenericProps = resolveSelfGenericProps;
//# sourceMappingURL=model.js.map