import * as i0 from '@angular/core';
import { inject, ChangeDetectorRef, Optional, SkipSelf, ViewChild, Input, ChangeDetectionStrategy, Component, InjectionToken, Injectable, Injector, Directive, ViewChildren, LOCALE_ID, EventEmitter, Output, Pipe, NgModule } from '@angular/core';
import * as i5 from '@angular/common';
import { CommonModule, NgClass, NgTemplateOutlet, formatDate, AsyncPipe, NgComponentOutlet } from '@angular/common';
import * as i2 from '@angular/forms';
import { ControlContainer, ReactiveFormsModule, Validators, FormGroupDirective, FormsModule, UntypedFormGroup, UntypedFormControl } from '@angular/forms';
import * as i1 from '@ng-bootstrap/ng-bootstrap';
import { NgbDateAdapter, NgbTimeAdapter, NgbDatepickerModule, NgbTimepickerModule, NgbInputDatepicker, NgbTimepicker, NgbTooltip, NgbTypeaheadModule, NgbDropdownModule, NgbTooltipModule } from '@ng-bootstrap/ng-bootstrap';
import * as i3 from '@ngx-validate/core';
import { NgxValidateCoreModule } from '@ngx-validate/core';
import { DateTimeAdapter, DateAdapter, TimeAdapter, DisabledDirective, EllipsisDirective, AbpVisibleDirective, NgxDatatableDefaultDirective, NgxDatatableListDirective, ThemeSharedModule } from '@abp/ng.theme.shared';
import { LinkedList } from '@abp/utils';
import * as i2$1 from '@abp/ng.core';
import { RestService, ConfigStateService, AbpValidators, TrackByService, ShowPasswordDirective, PermissionDirective, LocalizationModule, escapeHtmlChars, PermissionService, getShortDateShortTimeFormat, getShortTimeFormat, getShortDateFormat, LocalizationService, createLocalizationPipeKeyGenerator, CoreModule } from '@abp/ng.core';
import { of, map as map$1, filter, merge, pipe, zip } from 'rxjs';
import { map, debounceTime, distinctUntilChanged, switchMap, filter as filter$1, take } from 'rxjs/operators';
import * as i1$1 from '@swimlane/ngx-datatable';
import { NgxDatatableModule } from '@swimlane/ngx-datatable';

class PropList extends LinkedList {
}
class PropData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Prop {
    constructor(type, name, displayName, permission, visible = _ => true, isExtra = false, template, className, formText, tooltip, displayTextResolver) {
        this.type = type;
        this.name = name;
        this.displayName = displayName;
        this.permission = permission;
        this.visible = visible;
        this.isExtra = isExtra;
        this.template = template;
        this.className = className;
        this.formText = formText;
        this.tooltip = tooltip;
        this.displayTextResolver = displayTextResolver;
        this.displayName = this.displayName || this.name;
    }
}
class PropsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Props {
    get props() {
        const propList = new this._ctor();
        this.callbackList.forEach(callback => callback(propList));
        return propList;
    }
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class FormPropList extends PropList {
}
class FormProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = FormPropList;
    }
}
class GroupedFormPropList {
    constructor() {
        this.items = [];
        this.count = 1;
    }
    addItem(item) {
        const groupName = item.group?.name;
        let group = this.items.find(i => i.group?.name === groupName);
        if (group) {
            group.formPropList.addTail(item);
        }
        else {
            group = {
                formPropList: new FormPropList(),
                group: item.group || { name: `default${this.count++}`, className: item.group?.className },
            };
            group.formPropList.addHead(item);
            this.items.push(group);
        }
    }
}
class CreateFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class EditFormPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = FormProps;
    }
}
class FormProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName || '', options.permission || '', options.visible, options.isExtra, options.template, options.className, options.formText, options.tooltip);
        this.group = options.group;
        this.className = options.className;
        this.formText = options.formText;
        this.tooltip = options.tooltip;
        this.asyncValidators = options.asyncValidators || (_ => []);
        this.validators = options.validators || (_ => []);
        this.disabled = options.disabled || (_ => false);
        this.readonly = options.readonly || (_ => false);
        this.autocomplete = options.autocomplete || 'off';
        this.options = options.options;
        this.id = options.id || options.name;
        const defaultValue = options.defaultValue;
        this.defaultValue = isFalsyValue(defaultValue) ? defaultValue : defaultValue || '';
        this.displayTextResolver = options.displayTextResolver;
    }
    static create(options) {
        return new FormProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(FormProp.create);
    }
}
class FormPropData extends PropData {
    constructor(injector, record) {
        super();
        this.record = record;
        this.getInjected = injector.get.bind(injector);
    }
}
function isFalsyValue(defaultValue) {
    return [0, '', false].indexOf(defaultValue) > -1;
}

function selfFactory(dependency) {
    return dependency;
}

class ExtensibleDateTimePickerComponent {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.meridian = false;
    }
    setDate(dateStr) {
        this.date.writeValue(dateStr);
    }
    setTime(dateStr) {
        this.time.writeValue(dateStr);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleDateTimePickerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.1.8", type: ExtensibleDateTimePickerComponent, isStandalone: true, selector: "abp-extensible-date-time-picker", inputs: { prop: "prop", meridian: "meridian" }, viewQueries: [{ propertyName: "date", first: true, predicate: NgbInputDatepicker, descendants: true }, { propertyName: "time", first: true, predicate: NgbTimepicker, descendants: true }], exportAs: ["abpExtensibleDateTimePicker"], ngImport: i0, template: `
    <input
      [id]="prop.id"
      [formControlName]="prop.name"
      (ngModelChange)="setTime($event)"
      (click)="datepicker.open()"
      (keyup.space)="datepicker.open()"
      ngbDatepicker
      #datepicker="ngbDatepicker"
      type="text"
      class="form-control"
    />
    <ngb-timepicker
      #timepicker
      [formControlName]="prop.name"
      (ngModelChange)="setDate($event)"
      [meridian]="meridian"
    ></ngb-timepicker>
  `, isInline: true, dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "ngmodule", type: NgbDatepickerModule }, { kind: "directive", type: i1.NgbInputDatepicker, selector: "input[ngbDatepicker]", inputs: ["autoClose", "contentTemplate", "datepickerClass", "dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "placement", "popperOptions", "restoreFocus", "showWeekNumbers", "startDate", "container", "positionTarget", "weekdays", "disabled"], outputs: ["dateSelect", "navigate", "closed"], exportAs: ["ngbDatepicker"] }, { kind: "ngmodule", type: NgbTimepickerModule }, { kind: "component", type: i1.NgbTimepicker, selector: "ngb-timepicker", inputs: ["meridian", "spinners", "seconds", "hourStep", "minuteStep", "secondStep", "readonlyInputs", "size"], exportAs: ["ngbTimepicker"] }, { kind: "ngmodule", type: NgxValidateCoreModule }, { kind: "directive", type: i3.ValidationDirective, selector: "[formControl],[formControlName]", exportAs: ["validationDirective"] }], viewProviders: [
            {
                provide: ControlContainer,
                useFactory: selfFactory,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]],
            },
            {
                provide: NgbDateAdapter,
                useClass: DateTimeAdapter,
            },
            {
                provide: NgbTimeAdapter,
                useClass: DateTimeAdapter,
            },
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleDateTimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'abpExtensibleDateTimePicker',
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        NgbDatepickerModule,
                        NgbTimepickerModule,
                        NgxValidateCoreModule,
                    ],
                    selector: 'abp-extensible-date-time-picker',
                    template: `
    <input
      [id]="prop.id"
      [formControlName]="prop.name"
      (ngModelChange)="setTime($event)"
      (click)="datepicker.open()"
      (keyup.space)="datepicker.open()"
      ngbDatepicker
      #datepicker="ngbDatepicker"
      type="text"
      class="form-control"
    />
    <ngb-timepicker
      #timepicker
      [formControlName]="prop.name"
      (ngModelChange)="setDate($event)"
      [meridian]="meridian"
    ></ngb-timepicker>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    viewProviders: [
                        {
                            provide: ControlContainer,
                            useFactory: selfFactory,
                            deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                        },
                        {
                            provide: NgbDateAdapter,
                            useClass: DateTimeAdapter,
                        },
                        {
                            provide: NgbTimeAdapter,
                            useClass: DateTimeAdapter,
                        },
                    ],
                }]
        }], propDecorators: { prop: [{
                type: Input
            }], meridian: [{
                type: Input
            }], date: [{
                type: ViewChild,
                args: [NgbInputDatepicker]
            }], time: [{
                type: ViewChild,
                args: [NgbTimepicker]
            }] } });

const EXTENSIONS_IDENTIFIER = new InjectionToken('EXTENSIONS_IDENTIFIER');
const EXTENSIONS_ACTION_TYPE = new InjectionToken('EXTENSIONS_ACTION_TYPE');
const EXTENSIONS_ACTION_DATA = new InjectionToken('EXTENSIONS_ACTION_DATA');
const EXTENSIONS_ACTION_CALLBACK = new InjectionToken('EXTENSIONS_ACTION_DATA');
const PROP_DATA_STREAM = new InjectionToken('PROP_DATA_STREAM');
const ENTITY_PROP_TYPE_CLASSES = new InjectionToken('ENTITY_PROP_TYPE_CLASSES', {
    factory: () => ({}),
});
const EXTENSIONS_FORM_PROP = new InjectionToken('EXTENSIONS_FORM_PROP');
const EXTENSIONS_FORM_PROP_DATA = new InjectionToken('EXTENSIONS_FORM_PROP_DATA');

const EXTRA_PROPERTIES_KEY = 'extraProperties';

const TYPEAHEAD_TEXT_SUFFIX = '_Text';
const TYPEAHEAD_TEXT_SUFFIX_REGEX = /_Text$/;
function createTypeaheadOptions(lookup) {
    return (data, searchText) => searchText && data
        ? data
            .getInjected(RestService)
            .request({
            method: 'GET',
            url: lookup.url || '',
            params: {
                [lookup.filterParamName || '']: searchText,
            },
        }, { apiName: 'Default' })
            .pipe(map((response) => {
            const list = response[lookup.resultListPropertyName || ''];
            const mapToOption = (item) => ({
                key: item[lookup.displayPropertyName || ''],
                value: item[lookup.valuePropertyName || ''],
            });
            return list.map(mapToOption);
        }))
        : of([]);
}
function getTypeaheadType(lookup, name) {
    if (!lookup.url) {
        return name.endsWith(TYPEAHEAD_TEXT_SUFFIX) ? "hidden" /* ePropType.Hidden */ : undefined;
    }
    else {
        return "typeahead" /* ePropType.Typeahead */;
    }
}
function createTypeaheadDisplayNameGenerator(displayNameGeneratorFn, properties) {
    return (displayName, fallback) => {
        const name = removeTypeaheadTextSuffix(fallback.name || '');
        return displayNameGeneratorFn(displayName || properties[name].displayName, {
            name,
            resource: fallback.resource,
        });
    };
}
function addTypeaheadTextSuffix(name) {
    return name + TYPEAHEAD_TEXT_SUFFIX;
}
function hasTypeaheadTextSuffix(name) {
    return TYPEAHEAD_TEXT_SUFFIX_REGEX.test(name);
}
function removeTypeaheadTextSuffix(name) {
    return name.replace(TYPEAHEAD_TEXT_SUFFIX_REGEX, '');
}

class ExtensibleFormPropService {
    constructor() {
        this.#configStateService = inject(ConfigStateService);
        this.meridian$ = this.#configStateService
            .getDeep$('localization.currentCulture.dateTimeFormat.shortTimePattern')
            .pipe(map((shortTimePattern) => (shortTimePattern || '').includes('tt')));
    }
    #configStateService;
    isRequired(validator) {
        return (validator === Validators.required ||
            validator === AbpValidators.required ||
            validator.name === 'required');
    }
    getComponent(prop) {
        if (prop.template) {
            return 'template';
        }
        switch (prop.type) {
            case "boolean" /* ePropType.Boolean */:
                return 'checkbox';
            case "date" /* ePropType.Date */:
                return 'date';
            case "datetime" /* ePropType.DateTime */:
                return 'dateTime';
            case "hidden" /* ePropType.Hidden */:
                return 'hidden';
            case "multiselect" /* ePropType.MultiSelect */:
                return 'multiselect';
            case "text" /* ePropType.Text */:
                return 'textarea';
            case "time" /* ePropType.Time */:
                return 'time';
            case "typeahead" /* ePropType.Typeahead */:
                return 'typeahead';
            case "passwordinputgroup" /* ePropType.PasswordInputGroup */:
                return 'passwordinputgroup';
            default:
                return prop.options ? 'select' : 'input';
        }
    }
    getType(prop) {
        switch (prop.type) {
            case "date" /* ePropType.Date */:
            case "string" /* ePropType.String */:
                return 'text';
            case "boolean" /* ePropType.Boolean */:
                return 'checkbox';
            case "number" /* ePropType.Number */:
                return 'number';
            case "email" /* ePropType.Email */:
                return 'email';
            case "password" /* ePropType.Password */:
                return 'password';
            case "passwordinputgroup" /* ePropType.PasswordInputGroup */:
                return 'passwordinputgroup';
            default:
                return 'hidden';
        }
    }
    calcAsterisks(validators) {
        if (!validators)
            return '';
        const required = validators.find(v => this.isRequired(v));
        return required ? '*' : '';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormPropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormPropService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormPropService, decorators: [{
            type: Injectable
        }] });

class ExtensibleFormPropComponent {
    constructor() {
        this.service = inject(ExtensibleFormPropService);
        this.cdRef = inject(ChangeDetectorRef);
        this.track = inject(TrackByService);
        this.#groupDirective = inject(FormGroupDirective);
        this.injector = inject(Injector);
        this.form = this.#groupDirective.form;
        this.asterisk = '';
        this.containerClassName = 'mb-2';
        this.showPassword = false;
        this.options$ = of([]);
        this.validators = [];
        this.passwordKey = "ThemeShared.Extensions.PasswordComponent" /* eExtensibleComponents.PasswordComponent */;
        this.disabledFn = (data) => false;
        this.search = (text$) => text$
            ? text$.pipe(debounceTime(300), distinctUntilChanged(), switchMap(text => this.prop?.options?.(this.data, text) || of([])))
            : of([]);
        this.typeaheadFormatter = (option) => option.key;
        this.meridian$ = this.service.meridian$;
    }
    #groupDirective;
    get disabled() {
        return this.disabledFn(this.data);
    }
    setTypeaheadValue(selectedOption) {
        this.typeaheadModel = selectedOption || { key: null, value: null };
        const { key, value } = this.typeaheadModel;
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (valueControl?.value && !value)
            valueControl.markAsDirty();
        keyControl?.setValue(key);
        valueControl?.setValue(value);
    }
    get isInvalid() {
        const control = this.form.get(this.prop.name);
        return control?.touched && control.invalid;
    }
    getTypeaheadControls() {
        const { name } = this.prop;
        const extraPropName = `${EXTRA_PROPERTIES_KEY}.${name}`;
        const keyControl = this.form.get(addTypeaheadTextSuffix(extraPropName)) ||
            this.form.get(addTypeaheadTextSuffix(name));
        const valueControl = this.form.get(extraPropName) || this.form.get(name);
        return [keyControl, valueControl];
    }
    setAsterisk() {
        this.asterisk = this.service.calcAsterisks(this.validators);
    }
    ngAfterViewInit() {
        if (this.isFirstGroup && this.first && this.fieldRef) {
            this.fieldRef.nativeElement.focus();
        }
    }
    getComponent(prop) {
        return this.service.getComponent(prop);
    }
    getType(prop) {
        return this.service.getType(prop);
    }
    ngOnChanges({ prop, data }) {
        const currentProp = prop?.currentValue;
        const { options, readonly, disabled, validators, className, template } = currentProp || {};
        if (template) {
            this.injectorForCustomComponent = Injector.create({
                providers: [
                    {
                        provide: EXTENSIONS_FORM_PROP,
                        useValue: currentProp,
                    },
                    {
                        provide: EXTENSIONS_FORM_PROP_DATA,
                        useValue: data?.currentValue?.record,
                    },
                    { provide: ControlContainer, useExisting: FormGroupDirective },
                ],
                parent: this.injector,
            });
        }
        if (options)
            this.options$ = options(this.data);
        if (readonly)
            this.readonly = readonly(this.data);
        if (disabled) {
            this.disabledFn = disabled;
        }
        if (validators) {
            this.validators = validators(this.data);
            this.setAsterisk();
        }
        if (className !== undefined) {
            this.containerClassName = className;
        }
        const [keyControl, valueControl] = this.getTypeaheadControls();
        if (keyControl && valueControl)
            this.typeaheadModel = { key: keyControl.value, value: valueControl.value };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormPropComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ExtensibleFormPropComponent, isStandalone: true, selector: "abp-extensible-form-prop", inputs: { data: "data", prop: "prop", first: "first", isFirstGroup: "isFirstGroup" }, providers: [ExtensibleFormPropService], viewQueries: [{ propertyName: "fieldRef", first: true, predicate: ["field"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n  @switch (getComponent(prop)) {\r\n    @case ('template') {\r\n      <ng-container *ngComponentOutlet=\"prop.template; injector: injectorForCustomComponent\">\r\n      </ng-container>\r\n    }\r\n  }\r\n\r\n  <div [ngClass]=\"containerClassName\" class=\"mb-2\">\r\n    @switch (getComponent(prop)) {\r\n      @case ('input') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <input\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [autocomplete]=\"prop.autocomplete\"\r\n          [type]=\"getType(prop)\"\r\n          [abpDisabled]=\"disabled\"\r\n          [readonly]=\"readonly\"\r\n          class=\"form-control\"\r\n        />\r\n      }\r\n      @case ('hidden') {\r\n        <input [formControlName]=\"prop.name\" type=\"hidden\" />\r\n      }\r\n      @case ('checkbox') {\r\n        <div class=\"form-check\" validationTarget>\r\n          <input\r\n            #field\r\n            [id]=\"prop.id\"\r\n            [formControlName]=\"prop.name\"\r\n            [abpDisabled]=\"disabled\"\r\n            type=\"checkbox\"\r\n            class=\"form-check-input\"\r\n          />\r\n          <ng-template\r\n            [ngTemplateOutlet]=\"label\"\r\n            [ngTemplateOutletContext]=\"{ $implicit: 'form-check-label' }\"\r\n          ></ng-template>\r\n        </div>\r\n      }\r\n      @case ('select') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <select\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          class=\"form-select form-control\"\r\n        >\r\n          @for (option of options$ | async; track option.value) {\r\n            <option [ngValue]=\"option.value\">\r\n              @if (prop.isExtra) {\r\n                {{ '::' + option.key | abpLocalization }}\r\n              } @else {\r\n                {{ option.key }}\r\n              }\r\n            </option>\r\n          }\r\n        </select>\r\n      }\r\n      @case ('multiselect') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <select\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          multiple=\"multiple\"\r\n          class=\"form-select form-control\"\r\n        >\r\n          @for (option of options$ | async; track option.value) {\r\n            <option [ngValue]=\"option.value\">\r\n              @if (prop.isExtra) {\r\n                {{ '::' + option.key | abpLocalization }}\r\n              } @else {\r\n                {{ option.key }}\r\n              }\r\n            </option>\r\n          }\r\n        </select>\r\n      }\r\n      @case ('typeahead') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <div #typeahead class=\"position-relative\" validationStyle validationTarget>\r\n          <input\r\n            #field\r\n            [id]=\"prop.id\"\r\n            [autocomplete]=\"prop.autocomplete\"\r\n            [abpDisabled]=\"disabled\"\r\n            [ngbTypeahead]=\"search\"\r\n            [editable]=\"false\"\r\n            [inputFormatter]=\"typeaheadFormatter\"\r\n            [resultFormatter]=\"typeaheadFormatter\"\r\n            [ngModelOptions]=\"{ standalone: true }\"\r\n            [(ngModel)]=\"typeaheadModel\"\r\n            (selectItem)=\"setTypeaheadValue($event.item)\"\r\n            (blur)=\"setTypeaheadValue(typeaheadModel)\"\r\n            [class.is-invalid]=\"typeahead.classList.contains('is-invalid')\"\r\n            class=\"form-control\"\r\n          />\r\n          <input [formControlName]=\"prop.name\" type=\"hidden\" />\r\n        </div>\r\n      }\r\n      @case ('date') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <input\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          (click)=\"datepicker.open()\"\r\n          (keyup.space)=\"datepicker.open()\"\r\n          ngbDatepicker\r\n          #datepicker=\"ngbDatepicker\"\r\n          type=\"text\"\r\n          class=\"form-control\"\r\n        />\r\n      }\r\n      @case ('time') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <ngb-timepicker [formControlName]=\"prop.name\"></ngb-timepicker>\r\n      }\r\n      @case ('dateTime') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <abp-extensible-date-time-picker [prop]=\"prop\" [meridian]=\"meridian$ | async\" />\r\n      }\r\n      @case ('textarea') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <textarea\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          [readonly]=\"readonly\"\r\n          class=\"form-control\"\r\n        ></textarea>\r\n      }\r\n      @case ('passwordinputgroup') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <div class=\"input-group form-group\" validationTarget>\r\n          <input\r\n            class=\"form-control\"\r\n            [id]=\"prop.id\"\r\n            [formControlName]=\"prop.name\"\r\n            [abpShowPassword]=\"showPassword\"\r\n          />\r\n          <button class=\"btn btn-secondary\" type=\"button\" (click)=\"showPassword = !showPassword\">\r\n            <i\r\n              class=\"fa\"\r\n              aria-hidden=\"true\"\r\n              [ngClass]=\"{\r\n                'fa-eye-slash': !showPassword,\r\n                'fa-eye': showPassword,\r\n              }\"\r\n            ></i>\r\n          </button>\r\n        </div>\r\n      }\r\n    }\r\n\r\n    @if (prop.formText) {\r\n      <small class=\"text-muted d-block\">{{ prop.formText | abpLocalization }}</small>\r\n    }\r\n  </div>\r\n</ng-container>\r\n\r\n<ng-template #label let-classes>\r\n  <label [htmlFor]=\"prop.id\" [ngClass]=\"classes || 'form-label'\">\r\n    @if (prop.displayTextResolver) {\r\n      {{ prop.displayTextResolver(data) | abpLocalization }}\r\n    } @else {\r\n      @if (prop.isExtra) {\r\n        {{ '::' + prop.displayName | abpLocalization }}\r\n      } @else {\r\n        {{ prop.displayName | abpLocalization }}\r\n      }\r\n    }\r\n    {{ asterisk }}\r\n    @if (prop.tooltip) {\r\n      <i\r\n        [ngbTooltip]=\"prop.tooltip.text | abpLocalization\"\r\n        [placement]=\"prop.tooltip.placement || 'auto'\"\r\n        container=\"body\"\r\n        class=\"bi bi-info-circle\"\r\n      ></i>\r\n    }\r\n  </label>\r\n</ng-template>\r\n", dependencies: [{ kind: "component", type: ExtensibleDateTimePickerComponent, selector: "abp-extensible-date-time-picker", inputs: ["prop", "meridian"], exportAs: ["abpExtensibleDateTimePicker"] }, { kind: "ngmodule", type: NgbDatepickerModule }, { kind: "directive", type: i1.NgbInputDatepicker, selector: "input[ngbDatepicker]", inputs: ["autoClose", "contentTemplate", "datepickerClass", "dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "placement", "popperOptions", "restoreFocus", "showWeekNumbers", "startDate", "container", "positionTarget", "weekdays", "disabled"], outputs: ["dateSelect", "navigate", "closed"], exportAs: ["ngbDatepicker"] }, { kind: "ngmodule", type: NgbTimepickerModule }, { kind: "component", type: i1.NgbTimepicker, selector: "ngb-timepicker", inputs: ["meridian", "spinners", "seconds", "hourStep", "minuteStep", "secondStep", "readonlyInputs", "size"], exportAs: ["ngbTimepicker"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2.SelectMultipleControlValueAccessor, selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: DisabledDirective, selector: "[abpDisabled]", inputs: ["abpDisabled"] }, { kind: "ngmodule", type: NgxValidateCoreModule }, { kind: "directive", type: i3.ValidationStyleDirective, selector: "[validationStyle]", exportAs: ["validationStyle"] }, { kind: "directive", type: i3.ValidationTargetDirective, selector: "[validationTarget]", exportAs: ["validationTarget"] }, { kind: "directive", type: i3.ValidationDirective, selector: "[formControl],[formControlName]", exportAs: ["validationDirective"] }, { kind: "directive", type: NgbTooltip, selector: "[ngbTooltip]", inputs: ["animation", "autoClose", "placement", "popperOptions", "triggers", "positionTarget", "container", "disableTooltip", "tooltipClass", "tooltipContext", "openDelay", "closeDelay", "ngbTooltip"], outputs: ["shown", "hidden"], exportAs: ["ngbTooltip"] }, { kind: "ngmodule", type: NgbTypeaheadModule }, { kind: "directive", type: i1.NgbTypeahead, selector: "input[ngbTypeahead]", inputs: ["autocomplete", "container", "editable", "focusFirst", "inputFormatter", "ngbTypeahead", "resultFormatter", "resultTemplate", "selectOnExact", "showHint", "placement", "popperOptions", "popupClass"], outputs: ["selectItem"], exportAs: ["ngbTypeahead"] }, { kind: "directive", type: ShowPasswordDirective, selector: "[abpShowPassword]", inputs: ["abpShowPassword"] }, { kind: "directive", type: PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { kind: "ngmodule", type: LocalizationModule }, { kind: "pipe", type: i2$1.LocalizationPipe, name: "abpLocalization" }, { kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i5.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i5.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"], exportAs: ["ngComponentOutlet"] }, { kind: "directive", type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: i5.AsyncPipe, name: "async" }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], viewProviders: [
            {
                provide: ControlContainer,
                useFactory: selfFactory,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]],
            },
            { provide: NgbDateAdapter, useClass: DateAdapter },
            { provide: NgbTimeAdapter, useClass: TimeAdapter },
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormPropComponent, decorators: [{
            type: Component,
            args: [{ selector: 'abp-extensible-form-prop', imports: [
                        ExtensibleDateTimePickerComponent,
                        NgbDatepickerModule,
                        NgbTimepickerModule,
                        ReactiveFormsModule,
                        DisabledDirective,
                        NgxValidateCoreModule,
                        NgbTooltip,
                        NgbTypeaheadModule,
                        ShowPasswordDirective,
                        PermissionDirective,
                        LocalizationModule,
                        CommonModule,
                        FormsModule,
                    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [ExtensibleFormPropService], viewProviders: [
                        {
                            provide: ControlContainer,
                            useFactory: selfFactory,
                            deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                        },
                        { provide: NgbDateAdapter, useClass: DateAdapter },
                        { provide: NgbTimeAdapter, useClass: TimeAdapter },
                    ], template: "<ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n  @switch (getComponent(prop)) {\r\n    @case ('template') {\r\n      <ng-container *ngComponentOutlet=\"prop.template; injector: injectorForCustomComponent\">\r\n      </ng-container>\r\n    }\r\n  }\r\n\r\n  <div [ngClass]=\"containerClassName\" class=\"mb-2\">\r\n    @switch (getComponent(prop)) {\r\n      @case ('input') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <input\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [autocomplete]=\"prop.autocomplete\"\r\n          [type]=\"getType(prop)\"\r\n          [abpDisabled]=\"disabled\"\r\n          [readonly]=\"readonly\"\r\n          class=\"form-control\"\r\n        />\r\n      }\r\n      @case ('hidden') {\r\n        <input [formControlName]=\"prop.name\" type=\"hidden\" />\r\n      }\r\n      @case ('checkbox') {\r\n        <div class=\"form-check\" validationTarget>\r\n          <input\r\n            #field\r\n            [id]=\"prop.id\"\r\n            [formControlName]=\"prop.name\"\r\n            [abpDisabled]=\"disabled\"\r\n            type=\"checkbox\"\r\n            class=\"form-check-input\"\r\n          />\r\n          <ng-template\r\n            [ngTemplateOutlet]=\"label\"\r\n            [ngTemplateOutletContext]=\"{ $implicit: 'form-check-label' }\"\r\n          ></ng-template>\r\n        </div>\r\n      }\r\n      @case ('select') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <select\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          class=\"form-select form-control\"\r\n        >\r\n          @for (option of options$ | async; track option.value) {\r\n            <option [ngValue]=\"option.value\">\r\n              @if (prop.isExtra) {\r\n                {{ '::' + option.key | abpLocalization }}\r\n              } @else {\r\n                {{ option.key }}\r\n              }\r\n            </option>\r\n          }\r\n        </select>\r\n      }\r\n      @case ('multiselect') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <select\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          multiple=\"multiple\"\r\n          class=\"form-select form-control\"\r\n        >\r\n          @for (option of options$ | async; track option.value) {\r\n            <option [ngValue]=\"option.value\">\r\n              @if (prop.isExtra) {\r\n                {{ '::' + option.key | abpLocalization }}\r\n              } @else {\r\n                {{ option.key }}\r\n              }\r\n            </option>\r\n          }\r\n        </select>\r\n      }\r\n      @case ('typeahead') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <div #typeahead class=\"position-relative\" validationStyle validationTarget>\r\n          <input\r\n            #field\r\n            [id]=\"prop.id\"\r\n            [autocomplete]=\"prop.autocomplete\"\r\n            [abpDisabled]=\"disabled\"\r\n            [ngbTypeahead]=\"search\"\r\n            [editable]=\"false\"\r\n            [inputFormatter]=\"typeaheadFormatter\"\r\n            [resultFormatter]=\"typeaheadFormatter\"\r\n            [ngModelOptions]=\"{ standalone: true }\"\r\n            [(ngModel)]=\"typeaheadModel\"\r\n            (selectItem)=\"setTypeaheadValue($event.item)\"\r\n            (blur)=\"setTypeaheadValue(typeaheadModel)\"\r\n            [class.is-invalid]=\"typeahead.classList.contains('is-invalid')\"\r\n            class=\"form-control\"\r\n          />\r\n          <input [formControlName]=\"prop.name\" type=\"hidden\" />\r\n        </div>\r\n      }\r\n      @case ('date') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <input\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          (click)=\"datepicker.open()\"\r\n          (keyup.space)=\"datepicker.open()\"\r\n          ngbDatepicker\r\n          #datepicker=\"ngbDatepicker\"\r\n          type=\"text\"\r\n          class=\"form-control\"\r\n        />\r\n      }\r\n      @case ('time') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <ngb-timepicker [formControlName]=\"prop.name\"></ngb-timepicker>\r\n      }\r\n      @case ('dateTime') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <abp-extensible-date-time-picker [prop]=\"prop\" [meridian]=\"meridian$ | async\" />\r\n      }\r\n      @case ('textarea') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <textarea\r\n          #field\r\n          [id]=\"prop.id\"\r\n          [formControlName]=\"prop.name\"\r\n          [abpDisabled]=\"disabled\"\r\n          [readonly]=\"readonly\"\r\n          class=\"form-control\"\r\n        ></textarea>\r\n      }\r\n      @case ('passwordinputgroup') {\r\n        <ng-template [ngTemplateOutlet]=\"label\"></ng-template>\r\n        <div class=\"input-group form-group\" validationTarget>\r\n          <input\r\n            class=\"form-control\"\r\n            [id]=\"prop.id\"\r\n            [formControlName]=\"prop.name\"\r\n            [abpShowPassword]=\"showPassword\"\r\n          />\r\n          <button class=\"btn btn-secondary\" type=\"button\" (click)=\"showPassword = !showPassword\">\r\n            <i\r\n              class=\"fa\"\r\n              aria-hidden=\"true\"\r\n              [ngClass]=\"{\r\n                'fa-eye-slash': !showPassword,\r\n                'fa-eye': showPassword,\r\n              }\"\r\n            ></i>\r\n          </button>\r\n        </div>\r\n      }\r\n    }\r\n\r\n    @if (prop.formText) {\r\n      <small class=\"text-muted d-block\">{{ prop.formText | abpLocalization }}</small>\r\n    }\r\n  </div>\r\n</ng-container>\r\n\r\n<ng-template #label let-classes>\r\n  <label [htmlFor]=\"prop.id\" [ngClass]=\"classes || 'form-label'\">\r\n    @if (prop.displayTextResolver) {\r\n      {{ prop.displayTextResolver(data) | abpLocalization }}\r\n    } @else {\r\n      @if (prop.isExtra) {\r\n        {{ '::' + prop.displayName | abpLocalization }}\r\n      } @else {\r\n        {{ prop.displayName | abpLocalization }}\r\n      }\r\n    }\r\n    {{ asterisk }}\r\n    @if (prop.tooltip) {\r\n      <i\r\n        [ngbTooltip]=\"prop.tooltip.text | abpLocalization\"\r\n        [placement]=\"prop.tooltip.placement || 'auto'\"\r\n        container=\"body\"\r\n        class=\"bi bi-info-circle\"\r\n      ></i>\r\n    }\r\n  </label>\r\n</ng-template>\r\n" }]
        }], propDecorators: { data: [{
                type: Input
            }], prop: [{
                type: Input
            }], first: [{
                type: Input
            }], isFirstGroup: [{
                type: Input
            }], fieldRef: [{
                type: ViewChild,
                args: ['field']
            }] } });

class ActionList extends LinkedList {
}
class ActionData {
    get data() {
        return {
            getInjected: this.getInjected,
            index: this.index,
            record: this.record,
        };
    }
}
class Action {
    constructor(permission, visible = () => true, action = () => { }, btnClass, btnStyle) {
        this.permission = permission;
        this.visible = visible;
        this.action = action;
        this.btnClass = btnClass;
        this.btnStyle = btnStyle;
    }
}
class ActionsFactory {
    constructor() {
        this.contributorCallbacks = {};
    }
    get(name) {
        this.contributorCallbacks[name] = this.contributorCallbacks[name] || [];
        return new this._ctor(this.contributorCallbacks[name]);
    }
}
class Actions {
    get actions() {
        const actionList = new this._ctor();
        this.callbackList.forEach(callback => callback(actionList));
        return actionList;
    }
    constructor(callbackList) {
        this.callbackList = callbackList;
    }
    addContributor(contributeCallback) {
        this.callbackList.push(contributeCallback);
    }
    clearContributors() {
        while (this.callbackList.length)
            this.callbackList.pop();
    }
}

class EntityActionList extends ActionList {
}
class EntityActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = EntityActionList;
    }
}
class EntityActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityActions;
    }
}
class EntityAction extends Action {
    constructor(options) {
        super(options.permission || '', options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
        this.btnClass = options.btnClass || 'btn btn-primary text-center';
        this.btnStyle = options.btnStyle;
        this.showOnlyIcon = options.showOnlyIcon || false;
        this.tooltip = options.tooltip;
    }
    static create(options) {
        return new EntityAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityAction.create);
    }
}

class EntityPropList extends PropList {
}
class EntityProps extends Props {
    constructor() {
        super(...arguments);
        this._ctor = EntityPropList;
    }
}
class EntityPropsFactory extends PropsFactory {
    constructor() {
        super(...arguments);
        this._ctor = EntityProps;
    }
}
class EntityProp extends Prop {
    constructor(options) {
        super(options.type, options.name, options.displayName || '', options.permission || '', options.visible, options.isExtra);
        this.columnVisible = options.columnVisible || (() => true);
        this.columnWidth = options.columnWidth;
        this.sortable = options.sortable || false;
        this.valueResolver =
            options.valueResolver ||
                (data => of(escapeHtmlChars(data.record[this.name])));
        if (options.action) {
            this.action = options.action;
        }
        if (options.component) {
            this.component = options.component;
        }
        if (options.enumList) {
            this.enumList = options.enumList;
        }
        this.tooltip = options.tooltip;
    }
    static create(options) {
        return new EntityProp(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(EntityProp.create);
    }
}

class ToolbarActionList extends ActionList {
}
class ToolbarActions extends Actions {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActionList;
    }
}
class ToolbarActionsFactory extends ActionsFactory {
    constructor() {
        super(...arguments);
        this._ctor = ToolbarActions;
    }
}
class ToolbarAction extends Action {
    constructor(options) {
        super(options.permission || '', options.visible, options.action);
        this.text = options.text;
        this.icon = options.icon || '';
        if (options.btnClass) {
            this.btnClass = options.btnClass;
        }
    }
    static create(options) {
        return new ToolbarAction(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarAction.create);
    }
}
class ToolbarComponent extends Action {
    constructor(options) {
        super(options.permission || '', options.visible, options.action);
        this.component = options.component;
    }
    static create(options) {
        return new ToolbarComponent(options);
    }
    static createMany(arrayOfOptions) {
        return arrayOfOptions.map(ToolbarComponent.create);
    }
}

class ExtensionsService {
    constructor() {
        this.entityActions = new EntityActionsFactory();
        this.toolbarActions = new ToolbarActionsFactory();
        this.entityProps = new EntityPropsFactory();
        this.createFormProps = new CreateFormPropsFactory();
        this.editFormProps = new EditFormPropsFactory();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensionsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensionsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/* eslint-disable @angular-eslint/no-input-rename */
class PropDataDirective extends PropData {
    constructor(tempRef, vcRef, injector) {
        super();
        this.tempRef = tempRef;
        this.vcRef = vcRef;
        this.getInjected = injector.get.bind(injector);
    }
    ngOnChanges() {
        this.vcRef.clear();
        this.vcRef.createEmbeddedView(this.tempRef, {
            $implicit: this.data,
            index: 0,
        });
    }
    ngOnDestroy() {
        this.vcRef.clear();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PropDataDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: PropDataDirective, isStandalone: true, selector: "[abpPropData]", inputs: { propList: ["abpPropDataFromList", "propList"], record: ["abpPropDataWithRecord", "record"], index: ["abpPropDataAtIndex", "index"] }, exportAs: ["abpPropData"], usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PropDataDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'abpPropData',
                    selector: '[abpPropData]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.Injector }], propDecorators: { propList: [{
                type: Input,
                args: ['abpPropDataFromList']
            }], record: [{
                type: Input,
                args: ['abpPropDataWithRecord']
            }], index: [{
                type: Input,
                args: ['abpPropDataAtIndex']
            }] } });

class ExtensibleFormComponent {
    constructor() {
        this.cdRef = inject(ChangeDetectorRef);
        this.track = inject(TrackByService);
        this.container = inject(ControlContainer);
        this.extensions = inject(ExtensionsService);
        this.identifier = inject(EXTENSIONS_IDENTIFIER);
        this.extraPropertiesKey = EXTRA_PROPERTIES_KEY;
    }
    set selectedRecord(record) {
        const type = !record || JSON.stringify(record) === '{}' ? 'create' : 'edit';
        const propList = this.extensions[`${type}FormProps`].get(this.identifier).props;
        this.groupedPropList = this.createGroupedList(propList);
        this.record = record;
    }
    get form() {
        return (this.container ? this.container.control : { controls: {} });
    }
    get extraProperties() {
        return (this.form.controls.extraProperties || { controls: {} });
    }
    createGroupedList(propList) {
        const groupedFormPropList = new GroupedFormPropList();
        propList.forEach(item => {
            groupedFormPropList.addItem(item.value);
        });
        return groupedFormPropList;
    }
    //TODO: Reactor this method
    isAnyGroupMemberVisible(index, data) {
        const { items } = this.groupedPropList;
        const formPropList = items[index].formPropList.toArray();
        return formPropList.some(prop => prop.visible(data));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ExtensibleFormComponent, isStandalone: true, selector: "abp-extensible-form", inputs: { selectedRecord: "selectedRecord" }, viewQueries: [{ propertyName: "formProps", predicate: ExtensibleFormPropComponent, descendants: true }], exportAs: ["abpExtensibleForm"], ngImport: i0, template: "@if (form) {\r\n  @for (groupedProp of groupedPropList.items; track i; let i = $index; let first = $first) {\r\n    <ng-container *abpPropData=\"let data; fromList: groupedProp.formPropList; withRecord: record\">\r\n      @if (isAnyGroupMemberVisible(i, data) && groupedProp.group?.className) {\r\n        <div\r\n          [ngClass]=\"groupedProp.group?.className\"\r\n          [attr.data-name]=\"groupedProp.group?.name || groupedProp.group?.className\"\r\n        >\r\n          <ng-container\r\n            [ngTemplateOutlet]=\"propListTemplate\"\r\n            [ngTemplateOutletContext]=\"{ groupedProp: groupedProp, data: data, isFirstGroup: first}\"\r\n          >\r\n          </ng-container>\r\n        </div>\r\n      } @else {\r\n        <ng-container\r\n          [ngTemplateOutlet]=\"propListTemplate\"\r\n          [ngTemplateOutletContext]=\"{ groupedProp: groupedProp, data: data, isFirstGroup: first }\"\r\n        >\r\n        </ng-container>\r\n      }\r\n    </ng-container>\r\n  }\r\n}\r\n\r\n<ng-template let-groupedProp=\"groupedProp\" let-data=\"data\" let-isFirstGroup=\"isFirstGroup\" #propListTemplate>\r\n  @for (prop of groupedProp.formPropList; let index = $index; let first = $first; track prop.name) {\r\n    @if (prop.visible(data)) {\r\n      @if (extraProperties.controls[prop.name]) {\r\n        <ng-container [formGroupName]=\"extraPropertiesKey\">\r\n          <abp-extensible-form-prop [prop]=\"prop\" [data]=\"data\" [class]=\"prop.className\" />\r\n        </ng-container>\r\n      } @else {\r\n        @if (form.get(prop.name)) {\r\n          <abp-extensible-form-prop\r\n            [class]=\"prop.className\"\r\n            [prop]=\"prop\"\r\n            [data]=\"data\"\r\n            [first]=\"first\"\r\n            [isFirstGroup]=\"isFirstGroup\"\r\n          />\r\n        }\r\n      }\r\n    }\r\n  }\r\n</ng-template>\r\n", dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i5.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: PropDataDirective, selector: "[abpPropData]", inputs: ["abpPropDataFromList", "abpPropDataWithRecord", "abpPropDataAtIndex"], exportAs: ["abpPropData"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i2.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { kind: "component", type: ExtensibleFormPropComponent, selector: "abp-extensible-form-prop", inputs: ["data", "prop", "first", "isFirstGroup"] }], viewProviders: [
            {
                provide: ControlContainer,
                useFactory: selfFactory,
                deps: [[new Optional(), new SkipSelf(), ControlContainer]],
            },
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleFormComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpExtensibleForm', selector: 'abp-extensible-form', imports: [CommonModule, PropDataDirective, ReactiveFormsModule, ExtensibleFormPropComponent], changeDetection: ChangeDetectionStrategy.OnPush, viewProviders: [
                        {
                            provide: ControlContainer,
                            useFactory: selfFactory,
                            deps: [[new Optional(), new SkipSelf(), ControlContainer]],
                        },
                    ], template: "@if (form) {\r\n  @for (groupedProp of groupedPropList.items; track i; let i = $index; let first = $first) {\r\n    <ng-container *abpPropData=\"let data; fromList: groupedProp.formPropList; withRecord: record\">\r\n      @if (isAnyGroupMemberVisible(i, data) && groupedProp.group?.className) {\r\n        <div\r\n          [ngClass]=\"groupedProp.group?.className\"\r\n          [attr.data-name]=\"groupedProp.group?.name || groupedProp.group?.className\"\r\n        >\r\n          <ng-container\r\n            [ngTemplateOutlet]=\"propListTemplate\"\r\n            [ngTemplateOutletContext]=\"{ groupedProp: groupedProp, data: data, isFirstGroup: first}\"\r\n          >\r\n          </ng-container>\r\n        </div>\r\n      } @else {\r\n        <ng-container\r\n          [ngTemplateOutlet]=\"propListTemplate\"\r\n          [ngTemplateOutletContext]=\"{ groupedProp: groupedProp, data: data, isFirstGroup: first }\"\r\n        >\r\n        </ng-container>\r\n      }\r\n    </ng-container>\r\n  }\r\n}\r\n\r\n<ng-template let-groupedProp=\"groupedProp\" let-data=\"data\" let-isFirstGroup=\"isFirstGroup\" #propListTemplate>\r\n  @for (prop of groupedProp.formPropList; let index = $index; let first = $first; track prop.name) {\r\n    @if (prop.visible(data)) {\r\n      @if (extraProperties.controls[prop.name]) {\r\n        <ng-container [formGroupName]=\"extraPropertiesKey\">\r\n          <abp-extensible-form-prop [prop]=\"prop\" [data]=\"data\" [class]=\"prop.className\" />\r\n        </ng-container>\r\n      } @else {\r\n        @if (form.get(prop.name)) {\r\n          <abp-extensible-form-prop\r\n            [class]=\"prop.className\"\r\n            [prop]=\"prop\"\r\n            [data]=\"data\"\r\n            [first]=\"first\"\r\n            [isFirstGroup]=\"isFirstGroup\"\r\n          />\r\n        }\r\n      }\r\n    }\r\n  }\r\n</ng-template>\r\n" }]
        }], propDecorators: { formProps: [{
                type: ViewChildren,
                args: [ExtensibleFormPropComponent]
            }], selectedRecord: [{
                type: Input
            }] } });

// Fix for https://github.com/angular/angular/issues/23904
// @dynamic
class AbstractActionsComponent extends ActionData {
    constructor(injector) {
        super();
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        const type = injector.get(EXTENSIONS_ACTION_TYPE);
        this.actionList = extensions[type].get(name).actions;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbstractActionsComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.1.8", type: AbstractActionsComponent, isStandalone: true, inputs: { record: "record" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: AbstractActionsComponent, decorators: [{
            type: Directive
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { record: [{
                type: Input
            }] } });

class GridActionsComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.icon = 'fa fa-cog';
        this.text = '';
        this.trackByFn = (_, item) => item.text;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: GridActionsComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: GridActionsComponent, isStandalone: true, selector: "abp-grid-actions", inputs: { icon: "icon", index: "index", text: "text" }, providers: [
            {
                provide: EXTENSIONS_ACTION_TYPE,
                useValue: 'entityActions',
            },
        ], exportAs: ["abpGridActions"], usesInheritance: true, ngImport: i0, template: "@if (actionList.length > 1) {\r\n  <div ngbDropdown container=\"body\" class=\"d-inline-block\">\r\n    <button\r\n      class=\"btn btn-primary btn-sm dropdown-toggle\"\r\n      data-toggle=\"dropdown\"\r\n      aria-haspopup=\"true\"\r\n      ngbDropdownToggle\r\n    >\r\n      <i [ngClass]=\"icon\" [class.me-1]=\"icon\"></i>{{ text | abpLocalization }}\r\n    </button>\r\n    <div ngbDropdownMenu>\r\n      @for (action of actionList; track action.text) {\r\n        <ng-container\r\n          [ngTemplateOutlet]=\"dropDownBtnItemTmp\"\r\n          [ngTemplateOutletContext]=\"{ $implicit: action }\"\r\n        >\r\n        </ng-container>\r\n      }\r\n    </div>\r\n  </div>\r\n}\r\n\r\n@if (actionList.length === 1) {\r\n  <ng-container\r\n    [ngTemplateOutlet]=\"btnTmp\"\r\n    [ngTemplateOutletContext]=\"{ $implicit: actionList.get(0).value }\"\r\n  ></ng-container>\r\n}\r\n\r\n<ng-template #dropDownBtnItemTmp let-action>\r\n  @if (action.visible(data)) {\r\n    <button\r\n      ngbDropdownItem\r\n      *abpPermission=\"action.permission; runChangeDetection: false\"\r\n      (click)=\"action.action(data)\"\r\n      type=\"button\"\r\n    >\r\n      <ng-container\r\n        *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n      ></ng-container>\r\n    </button>\r\n  }\r\n</ng-template>\r\n\r\n<ng-template #buttonContentTmp let-action>\r\n  <i [ngClass]=\"action.icon\" [class.me-1]=\"action.icon && !action.showOnlyIcon\"></i>\r\n  @if (!action.showOnlyIcon) {\r\n    @if (action.icon) {\r\n      <span>{{ action.text | abpLocalization }}</span>\r\n    } @else {\r\n      <div abpEllipsis>{{ action.text | abpLocalization }}</div>\r\n    }\r\n  }\r\n</ng-template>\r\n\r\n<ng-template #btnTmp let-action>\r\n  @if (action.visible(data)) {\r\n    @if (action.tooltip) {\r\n      <button\r\n        *abpPermission=\"action.permission; runChangeDetection: false\"\r\n        (click)=\"action.action(data)\"\r\n        type=\"button\"\r\n        [class]=\"action.btnClass\"\r\n        [style]=\"action.btnStyle\"\r\n        [ngbTooltip]=\"action.tooltip.text | abpLocalization\"\r\n        [placement]=\"action.tooltip.placement || 'auto'\"\r\n        triggers=\"hover\"\r\n        container=\"body\"\r\n      >\r\n        <ng-container\r\n          *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n        ></ng-container>\r\n      </button>\r\n    } @else {\r\n      <button\r\n        *abpPermission=\"action.permission; runChangeDetection: false\"\r\n        (click)=\"action.action(data)\"\r\n        type=\"button\"\r\n        [class]=\"action.btnClass\"\r\n        [style]=\"action.btnStyle\"\r\n      >\r\n        <ng-container\r\n          *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n        ></ng-container>\r\n      </button>\r\n    }\r\n  }\r\n</ng-template>\r\n", dependencies: [{ kind: "ngmodule", type: NgbDropdownModule }, { kind: "directive", type: i1.NgbDropdown, selector: "[ngbDropdown]", inputs: ["autoClose", "dropdownClass", "open", "placement", "popperOptions", "container", "display"], outputs: ["openChange"], exportAs: ["ngbDropdown"] }, { kind: "directive", type: i1.NgbDropdownToggle, selector: "[ngbDropdownToggle]" }, { kind: "directive", type: i1.NgbDropdownMenu, selector: "[ngbDropdownMenu]" }, { kind: "directive", type: i1.NgbDropdownItem, selector: "[ngbDropdownItem]", inputs: ["tabindex", "disabled"] }, { kind: "directive", type: i1.NgbDropdownButtonItem, selector: "button[ngbDropdownItem]" }, { kind: "directive", type: EllipsisDirective, selector: "[abpEllipsis]", inputs: ["abpEllipsis", "title", "abpEllipsisEnabled"] }, { kind: "directive", type: PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "ngmodule", type: LocalizationModule }, { kind: "pipe", type: i2$1.LocalizationPipe, name: "abpLocalization" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "ngmodule", type: NgbTooltipModule }, { kind: "directive", type: i1.NgbTooltip, selector: "[ngbTooltip]", inputs: ["animation", "autoClose", "placement", "popperOptions", "triggers", "positionTarget", "container", "disableTooltip", "tooltipClass", "tooltipContext", "openDelay", "closeDelay", "ngbTooltip"], outputs: ["shown", "hidden"], exportAs: ["ngbTooltip"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: GridActionsComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpGridActions', imports: [
                        NgbDropdownModule,
                        EllipsisDirective,
                        PermissionDirective,
                        NgClass,
                        LocalizationModule,
                        NgTemplateOutlet,
                        NgbTooltipModule,
                    ], selector: 'abp-grid-actions', providers: [
                        {
                            provide: EXTENSIONS_ACTION_TYPE,
                            useValue: 'entityActions',
                        },
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "@if (actionList.length > 1) {\r\n  <div ngbDropdown container=\"body\" class=\"d-inline-block\">\r\n    <button\r\n      class=\"btn btn-primary btn-sm dropdown-toggle\"\r\n      data-toggle=\"dropdown\"\r\n      aria-haspopup=\"true\"\r\n      ngbDropdownToggle\r\n    >\r\n      <i [ngClass]=\"icon\" [class.me-1]=\"icon\"></i>{{ text | abpLocalization }}\r\n    </button>\r\n    <div ngbDropdownMenu>\r\n      @for (action of actionList; track action.text) {\r\n        <ng-container\r\n          [ngTemplateOutlet]=\"dropDownBtnItemTmp\"\r\n          [ngTemplateOutletContext]=\"{ $implicit: action }\"\r\n        >\r\n        </ng-container>\r\n      }\r\n    </div>\r\n  </div>\r\n}\r\n\r\n@if (actionList.length === 1) {\r\n  <ng-container\r\n    [ngTemplateOutlet]=\"btnTmp\"\r\n    [ngTemplateOutletContext]=\"{ $implicit: actionList.get(0).value }\"\r\n  ></ng-container>\r\n}\r\n\r\n<ng-template #dropDownBtnItemTmp let-action>\r\n  @if (action.visible(data)) {\r\n    <button\r\n      ngbDropdownItem\r\n      *abpPermission=\"action.permission; runChangeDetection: false\"\r\n      (click)=\"action.action(data)\"\r\n      type=\"button\"\r\n    >\r\n      <ng-container\r\n        *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n      ></ng-container>\r\n    </button>\r\n  }\r\n</ng-template>\r\n\r\n<ng-template #buttonContentTmp let-action>\r\n  <i [ngClass]=\"action.icon\" [class.me-1]=\"action.icon && !action.showOnlyIcon\"></i>\r\n  @if (!action.showOnlyIcon) {\r\n    @if (action.icon) {\r\n      <span>{{ action.text | abpLocalization }}</span>\r\n    } @else {\r\n      <div abpEllipsis>{{ action.text | abpLocalization }}</div>\r\n    }\r\n  }\r\n</ng-template>\r\n\r\n<ng-template #btnTmp let-action>\r\n  @if (action.visible(data)) {\r\n    @if (action.tooltip) {\r\n      <button\r\n        *abpPermission=\"action.permission; runChangeDetection: false\"\r\n        (click)=\"action.action(data)\"\r\n        type=\"button\"\r\n        [class]=\"action.btnClass\"\r\n        [style]=\"action.btnStyle\"\r\n        [ngbTooltip]=\"action.tooltip.text | abpLocalization\"\r\n        [placement]=\"action.tooltip.placement || 'auto'\"\r\n        triggers=\"hover\"\r\n        container=\"body\"\r\n      >\r\n        <ng-container\r\n          *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n        ></ng-container>\r\n      </button>\r\n    } @else {\r\n      <button\r\n        *abpPermission=\"action.permission; runChangeDetection: false\"\r\n        (click)=\"action.action(data)\"\r\n        type=\"button\"\r\n        [class]=\"action.btnClass\"\r\n        [style]=\"action.btnStyle\"\r\n      >\r\n        <ng-container\r\n          *ngTemplateOutlet=\"buttonContentTmp; context: { $implicit: action }\"\r\n        ></ng-container>\r\n      </button>\r\n    }\r\n  }\r\n</ng-template>\r\n" }]
        }], ctorParameters: () => [{ type: i0.Injector }], propDecorators: { icon: [{
                type: Input
            }], index: [{
                type: Input
            }], text: [{
                type: Input
            }] } });

const DEFAULT_ACTIONS_COLUMN_WIDTH = 150;
class ExtensibleTableComponent {
    #injector;
    set actionsText(value) {
        this._actionsText = value;
    }
    get actionsText() {
        return this._actionsText ?? (this.actionList.length > 1 ? 'AbpUi::Actions' : '');
    }
    set actionsColumnWidth(width) {
        this.setColumnWidths(width ? Number(width) : undefined);
    }
    constructor() {
        this.#injector = inject(Injector);
        this.getInjected = this.#injector.get.bind(this.#injector);
        this.cdr = inject(ChangeDetectorRef);
        this.locale = inject(LOCALE_ID);
        this.config = inject(ConfigStateService);
        this.entityPropTypeClasses = inject(ENTITY_PROP_TYPE_CLASSES);
        this.permissionService = inject(PermissionService);
        this.tableActivate = new EventEmitter();
        this.trackByFn = (_, item) => item.name;
        const extensions = this.#injector.get(ExtensionsService);
        const name = this.#injector.get(EXTENSIONS_IDENTIFIER);
        this.propList = extensions.entityProps.get(name).props;
        this.actionList = extensions['entityActions'].get(name)
            .actions;
        this.hasAtLeastOnePermittedAction =
            this.permissionService.filterItemsByPolicy(this.actionList.toArray().map(action => ({ requiredPolicy: action.permission }))).length > 0;
        this.setColumnWidths(DEFAULT_ACTIONS_COLUMN_WIDTH);
    }
    setColumnWidths(actionsColumn) {
        const widths = [actionsColumn];
        this.propList.forEach(({ value: prop }) => {
            widths.push(prop.columnWidth);
        });
        this.columnWidths = widths;
    }
    getDate(value, format) {
        return value && format ? formatDate(value, format, this.locale) : '';
    }
    getIcon(value) {
        return value
            ? '<div class="text-success"><i class="fa fa-check" aria-hidden="true"></i></div>'
            : '<div class="text-danger"><i class="fa fa-times" aria-hidden="true"></i></div>';
    }
    getEnum(rowValue, list) {
        if (!list || list.length < 1)
            return rowValue;
        const { key } = list.find(({ value }) => value === rowValue) || {};
        return key;
    }
    getContent(prop, data) {
        return prop.valueResolver(data).pipe(map$1(value => {
            switch (prop.type) {
                case "boolean" /* ePropType.Boolean */:
                    return this.getIcon(value);
                case "date" /* ePropType.Date */:
                    return this.getDate(value, getShortDateFormat(this.config));
                case "time" /* ePropType.Time */:
                    return this.getDate(value, getShortTimeFormat(this.config));
                case "datetime" /* ePropType.DateTime */:
                    return this.getDate(value, getShortDateShortTimeFormat(this.config));
                case "enum" /* ePropType.Enum */:
                    return this.getEnum(value, prop.enumList || []);
                default:
                    return value;
                // More types can be handled in the future
            }
        }));
    }
    ngOnChanges({ data }) {
        if (!data?.currentValue)
            return;
        if (data.currentValue.length < 1) {
            this.list.totalCount = this.recordsTotal;
        }
        this.data = data.currentValue.map((record, index) => {
            this.propList.forEach(prop => {
                const propData = { getInjected: this.getInjected, record, index };
                const value = this.getContent(prop.value, propData);
                const propKey = `_${prop.value.name}`;
                record[propKey] = {
                    visible: prop.value.visible(propData),
                    value,
                };
                if (prop.value.component) {
                    record[propKey].injector = Injector.create({
                        providers: [
                            {
                                provide: PROP_DATA_STREAM,
                                useValue: value,
                            },
                        ],
                        parent: this.#injector,
                    });
                    record[propKey].component = prop.value.component;
                }
            });
            return record;
        });
    }
    isVisibleActions(rowData) {
        const actions = this.actionList.toArray();
        const visibleActions = actions.filter(action => {
            const { visible, permission } = action;
            let isVisible = true;
            let hasPermission = true;
            if (visible) {
                isVisible = visible({ record: rowData, getInjected: this.getInjected });
            }
            if (permission) {
                hasPermission = this.permissionService.getGrantedPolicy(permission);
            }
            return isVisible && hasPermission;
        });
        return visibleActions.length > 0;
    }
    ngAfterViewInit() {
        this.list?.requestStatus$?.pipe(filter(status => status === 'loading')).subscribe(() => {
            this.data = [];
            this.cdr.markForCheck();
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: ExtensibleTableComponent, isStandalone: true, selector: "abp-extensible-table", inputs: { actionsText: "actionsText", data: "data", list: "list", recordsTotal: "recordsTotal", actionsColumnWidth: "actionsColumnWidth", actionsTemplate: "actionsTemplate" }, outputs: { tableActivate: "tableActivate" }, exportAs: ["abpExtensibleTable"], usesOnChanges: true, ngImport: i0, template: "<ngx-datatable\r\n  default\r\n  [rows]=\"data\"\r\n  [count]=\"recordsTotal\"\r\n  [list]=\"list\"\r\n  (activate)=\"tableActivate.emit($event)\"\r\n>\r\n  @if (actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)) {\r\n    <ngx-datatable-column\r\n      [name]=\"actionsText | abpLocalization\"\r\n      [maxWidth]=\"columnWidths[0]\"\r\n      [width]=\"columnWidths[0]\"\r\n      [sortable]=\"false\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n        <ng-container\r\n          *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n        ></ng-container>\r\n        <ng-template #gridActions>\r\n          @if (isVisibleActions(row)) {\r\n            <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n          }\r\n        </ng-template>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  }\r\n  @for (prop of propList; track prop.name; let i = $index) {\r\n    <ngx-datatable-column\r\n      *abpVisible=\"prop.columnVisible(getInjected)\"\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"(prop.isExtra ? '::' + prop.displayName : prop.displayName) | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template ngx-datatable-header-template let-column=\"column\">\r\n        @if (prop.tooltip) {\r\n          <span\r\n            [ngbTooltip]=\"prop.tooltip.text | abpLocalization\"\r\n            [placement]=\"prop.tooltip.placement || 'auto'\"\r\n            container=\"body\"\r\n          >\r\n            {{ column.name }} <i class=\"fa fa-info-circle\" aria-hidden=\"true\"></i>\r\n          </span>\r\n        } @else {\r\n          {{ column.name }}\r\n        }\r\n      </ng-template>\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *abpVisible=\"row['_' + prop.name]?.visible\">\r\n            @if (!row['_' + prop.name].component) {\r\n              <div\r\n                [innerHTML]=\"\r\n                  !prop.isExtra\r\n                    ? (row['_' + prop.name]?.value | async)\r\n                    : ('::' + (row['_' + prop.name]?.value | async) | abpLocalization)\r\n                \"\r\n                (click)=\"\r\n                  prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n                \"\r\n                [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n                [class.pointer]=\"prop.action\"\r\n              ></div>\r\n            } @else {\r\n              <ng-container\r\n                *ngComponentOutlet=\"\r\n                  row['_' + prop.name].component;\r\n                  injector: row['_' + prop.name].injector\r\n                \"\r\n              ></ng-container>\r\n            }\r\n          </ng-container>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  }\r\n</ngx-datatable>\r\n", dependencies: [{ kind: "directive", type: AbpVisibleDirective, selector: "[abpVisible]", inputs: ["abpVisible"] }, { kind: "ngmodule", type: NgxDatatableModule }, { kind: "component", type: i1$1.DatatableComponent, selector: "ngx-datatable", inputs: ["targetMarkerTemplate", "rows", "groupRowsBy", "groupedRows", "columns", "selected", "scrollbarV", "scrollbarH", "rowHeight", "columnMode", "headerHeight", "footerHeight", "externalPaging", "externalSorting", "limit", "count", "offset", "loadingIndicator", "selectionType", "reorderable", "swapColumns", "sortType", "sorts", "cssClasses", "messages", "rowClass", "selectCheck", "displayCheck", "groupExpansionDefault", "trackByProp", "selectAllRowsOnPage", "virtualization", "treeFromRelation", "treeToRelation", "summaryRow", "summaryHeight", "summaryPosition", "rowIdentity"], outputs: ["scroll", "activate", "select", "sort", "page", "reorder", "resize", "tableContextmenu", "treeAction"] }, { kind: "directive", type: i1$1.DataTableColumnDirective, selector: "ngx-datatable-column", inputs: ["name", "prop", "frozenLeft", "frozenRight", "flexGrow", "resizeable", "comparator", "pipe", "sortable", "draggable", "canAutoResize", "minWidth", "width", "maxWidth", "checkboxable", "headerCheckboxable", "headerClass", "cellClass", "isTreeColumn", "treeLevelIndent", "summaryFunc", "summaryTemplate", "cellTemplate", "headerTemplate", "treeToggleTemplate"] }, { kind: "directive", type: i1$1.DataTableColumnHeaderDirective, selector: "[ngx-datatable-header-template]" }, { kind: "directive", type: i1$1.DataTableColumnCellDirective, selector: "[ngx-datatable-cell-template]" }, { kind: "component", type: GridActionsComponent, selector: "abp-grid-actions", inputs: ["icon", "index", "text"], exportAs: ["abpGridActions"] }, { kind: "directive", type: NgbTooltip, selector: "[ngbTooltip]", inputs: ["animation", "autoClose", "placement", "popperOptions", "triggers", "positionTarget", "container", "disableTooltip", "tooltipClass", "tooltipContext", "openDelay", "closeDelay", "ngbTooltip"], outputs: ["shown", "hidden"], exportAs: ["ngbTooltip"] }, { kind: "directive", type: NgxDatatableDefaultDirective, selector: "ngx-datatable[default]", inputs: ["class"], exportAs: ["ngxDatatableDefault"] }, { kind: "directive", type: NgxDatatableListDirective, selector: "ngx-datatable[list]", inputs: ["list"], exportAs: ["ngxDatatableList"] }, { kind: "directive", type: PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { kind: "ngmodule", type: LocalizationModule }, { kind: "pipe", type: i2$1.LocalizationPipe, name: "abpLocalization" }, { kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"], exportAs: ["ngComponentOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleTableComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpExtensibleTable', selector: 'abp-extensible-table', imports: [
                        AbpVisibleDirective,
                        NgxDatatableModule,
                        GridActionsComponent,
                        NgbTooltip,
                        NgxDatatableDefaultDirective,
                        NgxDatatableListDirective,
                        PermissionDirective,
                        LocalizationModule,
                        AsyncPipe,
                        NgTemplateOutlet,
                        NgComponentOutlet,
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<ngx-datatable\r\n  default\r\n  [rows]=\"data\"\r\n  [count]=\"recordsTotal\"\r\n  [list]=\"list\"\r\n  (activate)=\"tableActivate.emit($event)\"\r\n>\r\n  @if (actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)) {\r\n    <ngx-datatable-column\r\n      [name]=\"actionsText | abpLocalization\"\r\n      [maxWidth]=\"columnWidths[0]\"\r\n      [width]=\"columnWidths[0]\"\r\n      [sortable]=\"false\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n        <ng-container\r\n          *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n        ></ng-container>\r\n        <ng-template #gridActions>\r\n          @if (isVisibleActions(row)) {\r\n            <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n          }\r\n        </ng-template>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  }\r\n  @for (prop of propList; track prop.name; let i = $index) {\r\n    <ngx-datatable-column\r\n      *abpVisible=\"prop.columnVisible(getInjected)\"\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"(prop.isExtra ? '::' + prop.displayName : prop.displayName) | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template ngx-datatable-header-template let-column=\"column\">\r\n        @if (prop.tooltip) {\r\n          <span\r\n            [ngbTooltip]=\"prop.tooltip.text | abpLocalization\"\r\n            [placement]=\"prop.tooltip.placement || 'auto'\"\r\n            container=\"body\"\r\n          >\r\n            {{ column.name }} <i class=\"fa fa-info-circle\" aria-hidden=\"true\"></i>\r\n          </span>\r\n        } @else {\r\n          {{ column.name }}\r\n        }\r\n      </ng-template>\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *abpVisible=\"row['_' + prop.name]?.visible\">\r\n            @if (!row['_' + prop.name].component) {\r\n              <div\r\n                [innerHTML]=\"\r\n                  !prop.isExtra\r\n                    ? (row['_' + prop.name]?.value | async)\r\n                    : ('::' + (row['_' + prop.name]?.value | async) | abpLocalization)\r\n                \"\r\n                (click)=\"\r\n                  prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n                \"\r\n                [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n                [class.pointer]=\"prop.action\"\r\n              ></div>\r\n            } @else {\r\n              <ng-container\r\n                *ngComponentOutlet=\"\r\n                  row['_' + prop.name].component;\r\n                  injector: row['_' + prop.name].injector\r\n                \"\r\n              ></ng-container>\r\n            }\r\n          </ng-container>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  }\r\n</ngx-datatable>\r\n" }]
        }], ctorParameters: () => [], propDecorators: { actionsText: [{
                type: Input
            }], data: [{
                type: Input
            }], list: [{
                type: Input
            }], recordsTotal: [{
                type: Input
            }], actionsColumnWidth: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }], tableActivate: [{
                type: Output
            }] } });

class CreateInjectorPipe {
    transform(_, action, context) {
        const get = (token, notFoundValue, options) => {
            const componentData = context.getData();
            const componentDataCallback = (data) => {
                data = data ?? context.getData();
                return action.action(data);
            };
            let extensionData;
            switch (token) {
                case EXTENSIONS_ACTION_DATA:
                    extensionData = componentData;
                    break;
                case EXTENSIONS_ACTION_CALLBACK:
                    extensionData = componentDataCallback;
                    break;
                default:
                    extensionData = context.getInjected.call(context.injector, token, notFoundValue, options);
            }
            return extensionData;
        };
        return { get };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CreateInjectorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: CreateInjectorPipe, isStandalone: true, name: "createInjector" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: CreateInjectorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'createInjector',
                    standalone: true,
                }]
        }] });

class PageToolbarComponent extends AbstractActionsComponent {
    constructor(injector) {
        super(injector);
        this.injector = injector;
        this.defaultBtnClass = 'btn btn-sm btn-primary';
        this.getData = () => this.data;
        this.trackByFn = (_, item) => item.action || item.component;
    }
    asToolbarAction(value) {
        return {
            value: value,
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PageToolbarComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.1.8", type: PageToolbarComponent, isStandalone: true, selector: "abp-page-toolbar", providers: [
            {
                provide: EXTENSIONS_ACTION_TYPE,
                useValue: 'toolbarActions',
            },
        ], exportAs: ["abpPageToolbar"], usesInheritance: true, ngImport: i0, template: "<div class=\"row justify-content-end mx-0 gap-2\" id=\"AbpContentToolbar\">\r\n  @for (action of actionList; track action.component || action.action; let last = $last) {\r\n  <div class=\"col-auto px-0 pt-0\" [class.pe-0]=\"last\">\r\n    @if (action.visible(data)) {\r\n    <ng-container *abpPermission=\"action.permission; runChangeDetection: false\">\r\n      @if (action.component; as component) {\r\n      <ng-container\r\n        *ngComponentOutlet=\"component; injector: record | createInjector: action:this\"\r\n      ></ng-container>\r\n\r\n      }@else {\r\n         @if (asToolbarAction(action).value; as toolbarAction ) {\r\n          <button\r\n            (click)=\"action.action(data)\"\r\n            type=\"button\"\r\n            [ngClass]=\"toolbarAction?.btnClass ? toolbarAction?.btnClass : defaultBtnClass\"\r\n            class=\"d-inline-flex align-items-center gap-1\"\r\n          >\r\n            <i [ngClass]=\"toolbarAction?.icon\" [class.me-1]=\"toolbarAction?.icon\"></i>\r\n            {{ toolbarAction?.text | abpLocalization }}\r\n          </button>\r\n        } \r\n      }\r\n    </ng-container>\r\n    }\r\n  </div>\r\n  }\r\n</div>\r\n\r\n", dependencies: [{ kind: "pipe", type: CreateInjectorPipe, name: "createInjector" }, { kind: "directive", type: PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { kind: "ngmodule", type: LocalizationModule }, { kind: "pipe", type: i2$1.LocalizationPipe, name: "abpLocalization" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInputs", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"], exportAs: ["ngComponentOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: PageToolbarComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpPageToolbar', selector: 'abp-page-toolbar', imports: [
                        CreateInjectorPipe,
                        PermissionDirective,
                        LocalizationModule,
                        NgClass,
                        NgComponentOutlet,
                    ], providers: [
                        {
                            provide: EXTENSIONS_ACTION_TYPE,
                            useValue: 'toolbarActions',
                        },
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"row justify-content-end mx-0 gap-2\" id=\"AbpContentToolbar\">\r\n  @for (action of actionList; track action.component || action.action; let last = $last) {\r\n  <div class=\"col-auto px-0 pt-0\" [class.pe-0]=\"last\">\r\n    @if (action.visible(data)) {\r\n    <ng-container *abpPermission=\"action.permission; runChangeDetection: false\">\r\n      @if (action.component; as component) {\r\n      <ng-container\r\n        *ngComponentOutlet=\"component; injector: record | createInjector: action:this\"\r\n      ></ng-container>\r\n\r\n      }@else {\r\n         @if (asToolbarAction(action).value; as toolbarAction ) {\r\n          <button\r\n            (click)=\"action.action(data)\"\r\n            type=\"button\"\r\n            [ngClass]=\"toolbarAction?.btnClass ? toolbarAction?.btnClass : defaultBtnClass\"\r\n            class=\"d-inline-flex align-items-center gap-1\"\r\n          >\r\n            <i [ngClass]=\"toolbarAction?.icon\" [class.me-1]=\"toolbarAction?.icon\"></i>\r\n            {{ toolbarAction?.text | abpLocalization }}\r\n          </button>\r\n        } \r\n      }\r\n    </ng-container>\r\n    }\r\n  </div>\r\n  }\r\n</div>\r\n\r\n" }]
        }], ctorParameters: () => [{ type: i0.Injector }] });

var objectExtensions = /*#__PURE__*/Object.freeze({
    __proto__: null
});

const EXTENSIBLE_FORM_VIEW_PROVIDER = { provide: ControlContainer, useExisting: FormGroupDirective };

function mergeWithDefaultActions(extension, defaultActions, ...contributors) {
    Object.keys(defaultActions).forEach((name) => {
        const actions = extension.get(name);
        actions.clearContributors();
        actions.addContributor((actionList) => actionList.addManyTail(defaultActions[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => actions.addContributor(callback)));
    });
}

function generateFormFromProps(data) {
    const extensions = data.getInjected((ExtensionsService));
    const identifier = data.getInjected(EXTENSIONS_IDENTIFIER);
    const form = new UntypedFormGroup({});
    const extraForm = new UntypedFormGroup({});
    form.addControl(EXTRA_PROPERTIES_KEY, extraForm);
    const record = data.record || {};
    const type = JSON.stringify(record) === '{}' ? 'create' : 'edit';
    const props = extensions[`${type}FormProps`].get(identifier).props;
    const extraProperties = record[EXTRA_PROPERTIES_KEY] || {};
    props.forEach(({ value: prop }) => {
        const name = prop.name;
        const isExtraProperty = prop.isExtra || name in extraProperties;
        let value = undefined;
        if (isExtraProperty) {
            value = extraProperties[name];
        }
        else if (name in record) {
            value = record[name];
        }
        if (typeof value === 'undefined')
            value = prop.defaultValue;
        if (value) {
            let adapter;
            switch (prop.type) {
                case "date" /* ePropType.Date */:
                    adapter = new DateAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "time" /* ePropType.Time */:
                    adapter = new TimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                case "datetime" /* ePropType.DateTime */:
                    adapter = new DateTimeAdapter();
                    value = adapter.toModel(adapter.fromModel(value));
                    break;
                default:
                    break;
            }
        }
        const formControl = new UntypedFormControl(value, {
            asyncValidators: prop.asyncValidators(data),
            validators: prop.validators(data),
        });
        (isExtraProperty ? extraForm : form).addControl(name, formControl);
    });
    return form;
}

function createExtraPropertyValueResolver(name) {
    return (data) => of(data.record[EXTRA_PROPERTIES_KEY][name]);
}
function mergeWithDefaultProps(extension, defaultProps, ...contributors) {
    Object.keys(defaultProps).forEach((name) => {
        const props = extension.get(name);
        props.clearContributors();
        props.addContributor((propList) => propList.addManyTail(defaultProps[name]));
        contributors.forEach(contributor => (contributor[name] || []).forEach((callback) => props.addContributor(callback)));
    });
}
function checkPolicies(injector, properties) {
    const configState = injector.get(ConfigStateService);
    const permission = injector.get(PermissionService);
    const props = Object.entries(properties);
    const checkPolicy = (policy) => {
        const { permissions, globalFeatures, features } = policy || {};
        const checks = [
            {
                items: permissions?.permissionNames,
                requiresAll: permissions?.requiresAll,
                check: (item) => permission.getGrantedPolicy(item),
            },
            {
                items: globalFeatures?.features,
                requiresAll: globalFeatures?.requiresAll,
                check: (item) => configState.getGlobalFeatureIsEnabled(item),
            },
            {
                items: features?.features,
                requiresAll: features?.requiresAll,
                check: (item) => configState.getFeatureIsEnabled(item),
            },
        ];
        return checks.every(({ items, requiresAll, check }) => {
            if (!items?.length) {
                return true;
            }
            return requiresAll ? items.every(check) : items.some(check);
        });
    };
    props.forEach(([name, property]) => {
        if (property.policy && !checkPolicy(property.policy)) {
            delete properties[name];
        }
    });
}

function createEnum(members) {
    const enumObject = {};
    members.forEach(({ name = '', value }) => {
        enumObject[(enumObject[name] = value)] = name;
    });
    return enumObject;
}
function createEnumValueResolver(enumType, lookupEnum, propName) {
    return data => {
        const value = data.record[EXTRA_PROPERTIES_KEY][propName];
        const key = lookupEnum.transformed[value];
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, localizeEnum(key));
    };
}
function createEnumOptions(enumType, lookupEnum) {
    return data => {
        const l10n = data.getInjected(LocalizationService);
        const localizeEnum = createEnumLocalizer(l10n, enumType, lookupEnum);
        return createLocalizationStream(l10n, lookupEnum.fields.map(({ name = '', value }) => ({
            key: localizeEnum(name),
            value,
        })));
    };
}
function createLocalizationStream(l10n, mapTarget) {
    return merge(of(null), l10n.languageChange$).pipe(map(() => mapTarget));
}
function createEnumLocalizer(l10n, enumType, lookupEnum) {
    const resource = lookupEnum.localizationResource;
    const shortType = getShortEnumType(enumType);
    return key => l10n.localizeWithFallbackSync([resource || ''], ['Enum:' + shortType + '.' + key, shortType + '.' + key, key], key);
}
function getShortEnumType(enumType) {
    return enumType.split('.').pop();
}

function createDisplayNameLocalizationPipeKeyGenerator(localization) {
    const generateLocalizationPipeKey = createLocalizationPipeKeyGenerator(localization);
    return (displayName, fallback) => {
        if (displayName && displayName.name)
            return generateLocalizationPipeKey([displayName.resource || ''], [displayName.name], displayName.name);
        const key = generateLocalizationPipeKey([fallback.resource || ''], ['DisplayName:' + fallback.name], undefined);
        if (key)
            return key;
        return generateLocalizationPipeKey([fallback.resource || ''], [fallback.name || ''], fallback.name);
    };
}

function getValidatorsFromProperty(property) {
    const validators = [];
    property.attributes.forEach(attr => {
        if (attr.typeSimple && attr.typeSimple in AbpValidators) {
            validators.push(AbpValidators[attr.typeSimple](attr.config));
        }
    });
    return validators;
}

function selectObjectExtensions(configState) {
    return configState.getOne$('objectExtensions');
}
function selectLocalization(configState) {
    return configState.getOne$('localization');
}
function selectEnums(configState) {
    return selectObjectExtensions(configState).pipe(map((extensions) => Object.keys(extensions.enums).reduce((acc, key) => {
        const { fields, localizationResource } = extensions.enums[key];
        acc[key] = {
            fields,
            localizationResource,
            transformed: createEnum(fields),
        };
        return acc;
    }, {})));
}
function getObjectExtensionEntitiesFromStore(injector, moduleKey) {
    const configState = injector.get(ConfigStateService);
    return selectObjectExtensions(configState).pipe(map(extensions => {
        if (!extensions)
            return null;
        return (extensions.modules[moduleKey] || {})
            .entities;
    }), map(entities => (isUndefined(entities) ? {} : entities)), filter$1(Boolean), take(1));
}
function mapEntitiesToContributors(injector, resource) {
    const configState = injector.get(ConfigStateService);
    return pipe(switchMap((entities) => zip(selectLocalization(configState), selectEnums(configState)).pipe(map(([localization, enums]) => {
        const generateDisplayName = createDisplayNameLocalizationPipeKeyGenerator(localization);
        return Object.keys(entities).reduce((acc, key) => {
            acc.prop[key] = [];
            acc.createForm[key] = [];
            acc.editForm[key] = [];
            const entity = entities[key];
            if (!entity) {
                return acc;
            }
            const properties = entity.properties;
            if (!properties) {
                return acc;
            }
            checkPolicies(injector, properties);
            const mapPropertiesToContributors = createPropertiesToContributorsMapper(generateDisplayName, resource, enums);
            return mapPropertiesToContributors(properties, acc, key);
        }, {
            prop: {},
            createForm: {},
            editForm: {},
        });
    }))), take(1));
}
function createPropertiesToContributorsMapper(generateDisplayName, resource, enums) {
    return (properties, contributors, key) => {
        const isExtra = true;
        const generateTypeaheadDisplayName = createTypeaheadDisplayNameGenerator(generateDisplayName, properties);
        Object.keys(properties).forEach((name) => {
            const property = properties[name];
            const propName = name;
            const lookup = property.ui.lookup || {};
            const type = getTypeaheadType(lookup, name) || getTypeFromProperty(property);
            const generateDN = hasTypeaheadTextSuffix(name)
                ? generateTypeaheadDisplayName
                : generateDisplayName;
            const displayName = generateDN(property.displayName, { name, resource });
            if (property.ui.onTable.isVisible) {
                const sortable = Boolean(property.ui.onTable.isSortable);
                const columnWidth = type === "boolean" /* ePropType.Boolean */ ? 150 : 250;
                const valueResolver = type === "enum" /* ePropType.Enum */ &&
                    property.type
                    ? createEnumValueResolver(property.type, enums[property.type], propName)
                    : createExtraPropertyValueResolver(propName);
                const entityProp = new EntityProp({
                    type,
                    name: propName,
                    displayName,
                    sortable,
                    columnWidth,
                    valueResolver,
                    isExtra,
                });
                const contributor = (propList) => propList.addTail(entityProp);
                contributors.prop[key].push(contributor);
            }
            const isOnCreateForm = property.ui.onCreateForm.isVisible;
            const isOnEditForm = property.ui.onEditForm.isVisible;
            if (isOnCreateForm || isOnEditForm) {
                const defaultValue = property.defaultValue;
                const formText = property.formText;
                const validators = () => getValidatorsFromProperty(property);
                let options;
                if (type === "enum" /* ePropType.Enum */)
                    options = createEnumOptions(propName, enums[property.type || '']);
                else if (type === "typeahead" /* ePropType.Typeahead */)
                    options = createTypeaheadOptions(lookup);
                const formProp = new FormProp({
                    type,
                    name: propName,
                    displayName,
                    options,
                    defaultValue,
                    validators,
                    isExtra,
                    formText,
                });
                const formContributor = (propList) => propList.addTail(formProp);
                if (isOnCreateForm)
                    contributors.createForm[key].push(formContributor);
                if (isOnEditForm)
                    contributors.editForm[key].push(formContributor);
            }
        });
        return contributors;
    };
}
function getTypeFromProperty(property) {
    return property?.typeSimple?.replace(/\?$/, '');
}
function isUndefined(obj) {
    return typeof obj === 'undefined';
}

const importWithExport = [
    DisabledDirective,
    ExtensibleDateTimePickerComponent,
    ExtensibleFormPropComponent,
    GridActionsComponent,
    PropDataDirective,
    PageToolbarComponent,
    CreateInjectorPipe,
    ExtensibleFormComponent,
    ExtensibleTableComponent,
];
class ExtensibleModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleModule, imports: [CoreModule,
            ThemeSharedModule,
            NgxValidateCoreModule,
            NgbDatepickerModule,
            NgbDropdownModule,
            NgbTimepickerModule,
            NgbTypeaheadModule,
            NgbTooltipModule, DisabledDirective,
            ExtensibleDateTimePickerComponent,
            ExtensibleFormPropComponent,
            GridActionsComponent,
            PropDataDirective,
            PageToolbarComponent,
            CreateInjectorPipe,
            ExtensibleFormComponent,
            ExtensibleTableComponent], exports: [DisabledDirective,
            ExtensibleDateTimePickerComponent,
            ExtensibleFormPropComponent,
            GridActionsComponent,
            PropDataDirective,
            PageToolbarComponent,
            CreateInjectorPipe,
            ExtensibleFormComponent,
            ExtensibleTableComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleModule, imports: [CoreModule,
            ThemeSharedModule,
            NgxValidateCoreModule,
            NgbDatepickerModule,
            NgbDropdownModule,
            NgbTimepickerModule,
            NgbTypeaheadModule,
            NgbTooltipModule, ExtensibleDateTimePickerComponent,
            ExtensibleFormPropComponent,
            GridActionsComponent,
            PageToolbarComponent,
            ExtensibleFormComponent,
            ExtensibleTableComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.1.8", ngImport: i0, type: ExtensibleModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [
                        CoreModule,
                        ThemeSharedModule,
                        NgxValidateCoreModule,
                        NgbDatepickerModule,
                        NgbDropdownModule,
                        NgbTimepickerModule,
                        NgbTypeaheadModule,
                        NgbTooltipModule,
                        ...importWithExport,
                    ],
                    exports: [...importWithExport],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ActionList, CreateFormPropsFactory, CreateInjectorPipe, ENTITY_PROP_TYPE_CLASSES, EXTENSIBLE_FORM_VIEW_PROVIDER, EXTENSIONS_ACTION_CALLBACK, EXTENSIONS_ACTION_DATA, EXTENSIONS_ACTION_TYPE, EXTENSIONS_FORM_PROP, EXTENSIONS_FORM_PROP_DATA, EXTENSIONS_IDENTIFIER, EXTRA_PROPERTIES_KEY, EditFormPropsFactory, EntityAction, EntityActionList, EntityActions, EntityActionsFactory, EntityProp, EntityPropList, EntityProps, EntityPropsFactory, ExtensibleDateTimePickerComponent, ExtensibleFormComponent, ExtensibleFormPropComponent, ExtensibleModule, ExtensibleTableComponent, ExtensionsService, FormProp, FormPropData, FormPropList, FormProps, GridActionsComponent, objectExtensions as ObjectExtensions, PROP_DATA_STREAM, PageToolbarComponent, PropDataDirective, PropList, ToolbarAction, ToolbarActionList, ToolbarActions, ToolbarActionsFactory, ToolbarComponent, checkPolicies, createExtraPropertyValueResolver, generateFormFromProps, getObjectExtensionEntitiesFromStore, mapEntitiesToContributors, mergeWithDefaultActions, mergeWithDefaultProps };
//# sourceMappingURL=abp-ng.components-extensible.mjs.map
