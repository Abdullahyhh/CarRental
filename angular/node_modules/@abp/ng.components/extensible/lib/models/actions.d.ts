import { LinkedList } from '@abp/utils';
import { InjectFlags, InjectionToken, InjectOptions, Type } from '@angular/core';
export declare abstract class ActionList<R = any, A = Action<R>> extends LinkedList<A> {
}
export declare abstract class ActionData<R = any> {
    abstract getInjected: <T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectOptions | InjectFlags) => T;
    index?: number;
    abstract record: R;
    get data(): ReadonlyActionData<R>;
}
export type ReadonlyActionData<R = any> = Readonly<Omit<ActionData<R>, 'data'>>;
export declare abstract class Action<R = any> {
    readonly permission: string;
    readonly visible: ActionPredicate<R>;
    readonly action: ActionCallback<R>;
    readonly btnClass?: string;
    readonly btnStyle?: string;
    constructor(permission: string, visible?: ActionPredicate<R>, action?: ActionCallback<R>, btnClass?: string, btnStyle?: string);
}
export type ActionCallback<T, R = any> = (data: Omit<ActionData<T>, 'data'>) => R;
export type ActionPredicate<T> = (data?: Omit<ActionData<T>, 'data'>) => boolean;
export declare abstract class ActionsFactory<C extends Actions<any>> {
    protected abstract _ctor: Type<C>;
    private contributorCallbacks;
    get(name: string): C;
}
export declare abstract class Actions<L extends ActionList<any, InferredAction<L>>> {
    private readonly callbackList;
    protected abstract _ctor: Type<L>;
    get actions(): L;
    constructor(callbackList: ActionContributorCallback<L>[]);
    addContributor(contributeCallback: ActionContributorCallback<L>): void;
    clearContributors(): void;
}
export type ActionContributorCallbacks<L extends ActionList<any, InferredAction<L>>> = Record<string, ActionContributorCallback<L>[]>;
export type ActionContributorCallback<L extends ActionList<any, InferredAction<L>>> = (actionList: L) => any;
export type InferredAction<T> = T extends ActionList<any, infer U> ? U : T;
